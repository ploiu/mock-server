////// GENERATED CODE
type UI = {
  uiHtml: string;
  uiCss: string;
  uiJs: string;
};
export default {
  uiHtml:
    '<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <link rel="icon" type="image/svg+xml" href="/vite.svg" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vite + Vue + TS</title>\n    <script type="module" crossorigin src="./ui.js"></script>\n    <link rel="stylesheet" crossorigin href="./ui.css">\n  </head>\n  <body>\n    <div id="app"></div>\n  </body>\n</html>\n',
  uiCss:
    '\n:root{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;line-height:1.5;font-weight:400;color-scheme:light dark;color:#ffffffde;background-color:#242424;font-synthesis:none;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}a{font-weight:500;color:#646cff;text-decoration:inherit}a:hover{color:#535bf2}body{margin:0;display:flex;place-items:center;min-width:320px;min-height:100vh}h1{font-size:3.2em;line-height:1.1}button{border-radius:8px;border:1px solid transparent;padding:.6em 1.2em;font-size:1em;font-weight:500;font-family:inherit;background-color:#1a1a1a;cursor:pointer;transition:border-color .25s}button:hover{border-color:#646cff}button:focus,button:focus-visible{outline:4px auto -webkit-focus-ring-color}.card{padding:2em}#app{max-width:1280px;margin:0 auto;padding:2rem;text-align:center}@media (prefers-color-scheme: light){:root{color:#213547;background-color:#fff}a:hover{color:#747bff}button{background-color:#f9f9f9}}.read-the-docs[data-v-aba76ec8]{color:#888}.logo[data-v-27cb24bb]{height:6em;padding:1.5em;will-change:filter}.logo[data-v-27cb24bb]:hover{filter:drop-shadow(0 0 2em #646cffaa)}.logo.vue[data-v-27cb24bb]:hover{filter:drop-shadow(0 0 2em #42b883aa)}\n',
  uiJs:
    ";\n(function () {\n  const t = document.createElement('link').relList;\n  if (t && t.supports && t.supports('modulepreload')) return;\n  for (const r of document.querySelectorAll('link[rel=\"modulepreload\"]')) s(r);\n  new MutationObserver((r) => {\n    for (const i of r) {\n      if (i.type === 'childList') {\n        for (const l of i.addedNodes) {\n          l.tagName === 'LINK' && l.rel === 'modulepreload' && s(l);\n        }\n      }\n    }\n  }).observe(document, { childList: !0, subtree: !0 });\n  function n(r) {\n    const i = {};\n    return r.integrity && (i.integrity = r.integrity),\n      r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy),\n      r.crossOrigin === 'use-credentials'\n        ? i.credentials = 'include'\n        : r.crossOrigin === 'anonymous'\n        ? i.credentials = 'omit'\n        : i.credentials = 'same-origin',\n      i;\n  }\n  function s(r) {\n    if (r.ep) return;\n    r.ep = !0;\n    const i = n(r);\n    fetch(r.href, i);\n  }\n})(); /**\n * @vue/shared v3.4.26\n * (c) 2018-present Yuxi (Evan) You and Vue contributors\n * @license MIT\n */\n\n/*! #__NO_SIDE_EFFECTS__ */ function gn(e, t) {\n  const n = new Set(e.split(','));\n  return (s) => n.has(s);\n}\nconst U = {},\n  qe = [],\n  oe = () => {},\n  Or = () => !1,\n  Ft = (e) =>\n    e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 &&\n    (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97),\n  _n = (e) => e.startsWith('onUpdate:'),\n  z = Object.assign,\n  mn = (e, t) => {\n    const n = e.indexOf(t);\n    n > -1 && e.splice(n, 1);\n  },\n  Sr = Object.prototype.hasOwnProperty,\n  A = (e, t) => Sr.call(e, t),\n  I = Array.isArray,\n  ze = (e) => Lt(e) === '[object Map]',\n  vs = (e) => Lt(e) === '[object Set]',\n  P = (e) => typeof e == 'function',\n  G = (e) => typeof e == 'string',\n  Be = (e) => typeof e == 'symbol',\n  D = (e) => e !== null && typeof e == 'object',\n  ws = (e) => (D(e) || P(e)) && P(e.then) && P(e.catch),\n  Es = Object.prototype.toString,\n  Lt = (e) => Es.call(e),\n  Ir = (e) => Lt(e).slice(8, -1),\n  Cs = (e) => Lt(e) === '[object Object]',\n  bn = (e) => G(e) && e !== 'NaN' && e[0] !== '-' && '' + parseInt(e, 10) === e,\n  nt = gn(\n    ',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted',\n  ),\n  Ht = (e) => {\n    const t = Object.create(null);\n    return (n) => t[n] || (t[n] = e(n));\n  },\n  Tr = /-(\\w)/g,\n  Je = Ht((e) => e.replace(Tr, (t, n) => n ? n.toUpperCase() : '')),\n  Pr = /\\B([A-Z])/g,\n  Ze = Ht((e) => e.replace(Pr, '-$1').toLowerCase()),\n  Os = Ht((e) => e.charAt(0).toUpperCase() + e.slice(1)),\n  Gt = Ht((e) => e ? `on${Os(e)}` : ''),\n  Re = (e, t) => !Object.is(e, t),\n  Jt = (e, t) => {\n    for (let n = 0; n < e.length; n++) e[n](t);\n  },\n  Ss = (e, t, n, s = !1) => {\n    Object.defineProperty(e, t, {\n      configurable: !0,\n      enumerable: !1,\n      writable: s,\n      value: n,\n    });\n  },\n  Rr = (e) => {\n    const t = parseFloat(e);\n    return isNaN(t) ? e : t;\n  };\nlet Kn;\nconst Is = () =>\n  Kn ||\n  (Kn = typeof globalThis < 'u'\n    ? globalThis\n    : typeof self < 'u'\n    ? self\n    : typeof window < 'u'\n    ? window\n    : typeof global < 'u'\n    ? global\n    : {});\nfunction yn(e) {\n  if (I(e)) {\n    const t = {};\n    for (let n = 0; n < e.length; n++) {\n      const s = e[n], r = G(s) ? Lr(s) : yn(s);\n      if (r) for (const i in r) t[i] = r[i];\n    }\n    return t;\n  } else if (G(e) || D(e)) return e;\n}\nconst Ar = /;(?![^(]*\\))/g, Mr = /:([^]+)/, Fr = /\\/\\*[^]*?\\*\\//g;\nfunction Lr(e) {\n  const t = {};\n  return e.replace(Fr, '').split(Ar).forEach((n) => {\n    if (n) {\n      const s = n.split(Mr);\n      s.length > 1 && (t[s[0].trim()] = s[1].trim());\n    }\n  }),\n    t;\n}\nfunction xn(e) {\n  let t = '';\n  if (G(e)) t = e;\n  else if (I(e)) {\n    for (let n = 0; n < e.length; n++) {\n      const s = xn(e[n]);\n      s && (t += s + ' ');\n    }\n  } else if (D(e)) for (const n in e) e[n] && (t += n + ' ');\n  return t.trim();\n}\nconst Hr =\n    'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',\n  Nr = gn(Hr);\nfunction Ts(e) {\n  return !!e || e === '';\n}\nconst Wn = (e) =>\n    G(e)\n      ? e\n      : e == null\n      ? ''\n      : I(e) || D(e) && (e.toString === Es || !P(e.toString))\n      ? JSON.stringify(e, Ps, 2)\n      : String(e),\n  Ps = (e, t) =>\n    t && t.__v_isRef ? Ps(e, t.value) : ze(t)\n      ? {\n        [`Map(${t.size})`]: [...t.entries()].reduce(\n          (n, [s, r], i) => (n[Yt(s, i) + ' =>'] = r, n),\n          {},\n        ),\n      }\n      : vs(t)\n      ? { [`Set(${t.size})`]: [...t.values()].map((n) => Yt(n)) }\n      : Be(t)\n      ? Yt(t)\n      : D(t) && !I(t) && !Cs(t)\n      ? String(t)\n      : t,\n  Yt = (e, t = '') => {\n    var n;\n    return Be(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e;\n  }; /**\n * @vue/reactivity v3.4.26\n * (c) 2018-present Yuxi (Evan) You and Vue contributors\n * @license MIT\n */\n\nlet ce;\nclass jr {\n  constructor(t = !1) {\n    this.detached = t,\n      this._active = !0,\n      this.effects = [],\n      this.cleanups = [],\n      this.parent = ce,\n      !t && ce && (this.index = (ce.scopes || (ce.scopes = [])).push(this) - 1);\n  }\n  get active() {\n    return this._active;\n  }\n  run(t) {\n    if (this._active) {\n      const n = ce;\n      try {\n        return ce = this, t();\n      } finally {\n        ce = n;\n      }\n    }\n  }\n  on() {\n    ce = this;\n  }\n  off() {\n    ce = this.parent;\n  }\n  stop(t) {\n    if (this._active) {\n      let n, s;\n      for (n = 0, s = this.effects.length; n < s; n++) this.effects[n].stop();\n      for (n = 0, s = this.cleanups.length; n < s; n++) this.cleanups[n]();\n      if (this.scopes) {\n        for (n = 0, s = this.scopes.length; n < s; n++) {\n          this.scopes[n].stop(!0);\n        }\n      }\n      if (!this.detached && this.parent && !t) {\n        const r = this.parent.scopes.pop();\n        r && r !== this &&\n          (this.parent.scopes[this.index] = r, r.index = this.index);\n      }\n      this.parent = void 0, this._active = !1;\n    }\n  }\n}\nfunction $r(e, t = ce) {\n  t && t.active && t.effects.push(e);\n}\nfunction Ur() {\n  return ce;\n}\nlet Ue;\nclass vn {\n  constructor(t, n, s, r) {\n    this.fn = t,\n      this.trigger = n,\n      this.scheduler = s,\n      this.active = !0,\n      this.deps = [],\n      this._dirtyLevel = 4,\n      this._trackId = 0,\n      this._runnings = 0,\n      this._shouldSchedule = !1,\n      this._depsLength = 0,\n      $r(this, r);\n  }\n  get dirty() {\n    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {\n      this._dirtyLevel = 1, Ae();\n      for (let t = 0; t < this._depsLength; t++) {\n        const n = this.deps[t];\n        if (n.computed && (Vr(n.computed), this._dirtyLevel >= 4)) break;\n      }\n      this._dirtyLevel === 1 && (this._dirtyLevel = 0), Me();\n    }\n    return this._dirtyLevel >= 4;\n  }\n  set dirty(t) {\n    this._dirtyLevel = t ? 4 : 0;\n  }\n  run() {\n    if (this._dirtyLevel = 0, !this.active) return this.fn();\n    let t = Ie, n = Ue;\n    try {\n      return Ie = !0, Ue = this, this._runnings++, qn(this), this.fn();\n    } finally {\n      zn(this), this._runnings--, Ue = n, Ie = t;\n    }\n  }\n  stop() {\n    this.active &&\n      (qn(this), zn(this), this.onStop && this.onStop(), this.active = !1);\n  }\n}\nfunction Vr(e) {\n  return e.value;\n}\nfunction qn(e) {\n  e._trackId++, e._depsLength = 0;\n}\nfunction zn(e) {\n  if (e.deps.length > e._depsLength) {\n    for (let t = e._depsLength; t < e.deps.length; t++) Rs(e.deps[t], e);\n    e.deps.length = e._depsLength;\n  }\n}\nfunction Rs(e, t) {\n  const n = e.get(t);\n  n !== void 0 && t._trackId !== n &&\n    (e.delete(t), e.size === 0 && e.cleanup());\n}\nlet Ie = !0, sn = 0;\nconst As = [];\nfunction Ae() {\n  As.push(Ie), Ie = !1;\n}\nfunction Me() {\n  const e = As.pop();\n  Ie = e === void 0 ? !0 : e;\n}\nfunction wn() {\n  sn++;\n}\nfunction En() {\n  for (sn--; !sn && rn.length;) rn.shift()();\n}\nfunction Ms(e, t, n) {\n  if (t.get(e) !== e._trackId) {\n    t.set(e, e._trackId);\n    const s = e.deps[e._depsLength];\n    s !== t ? (s && Rs(s, e), e.deps[e._depsLength++] = t) : e._depsLength++;\n  }\n}\nconst rn = [];\nfunction Fs(e, t, n) {\n  wn();\n  for (const s of e.keys()) {\n    let r;\n    s._dirtyLevel < t && (r ?? (r = e.get(s) === s._trackId)) &&\n    (s._shouldSchedule || (s._shouldSchedule = s._dirtyLevel === 0),\n      s._dirtyLevel = t),\n      s._shouldSchedule && (r ?? (r = e.get(s) === s._trackId)) &&\n      (s.trigger(),\n        (!s._runnings || s.allowRecurse) && s._dirtyLevel !== 2 &&\n        (s._shouldSchedule = !1, s.scheduler && rn.push(s.scheduler)));\n  }\n  En();\n}\nconst Ls = (e, t) => {\n    const n = new Map();\n    return n.cleanup = e, n.computed = t, n;\n  },\n  on = new WeakMap(),\n  Ve = Symbol(''),\n  ln = Symbol('');\nfunction te(e, t, n) {\n  if (Ie && Ue) {\n    let s = on.get(e);\n    s || on.set(e, s = new Map());\n    let r = s.get(n);\n    r || s.set(n, r = Ls(() => s.delete(n))), Ms(Ue, r);\n  }\n}\nfunction ve(e, t, n, s, r, i) {\n  const l = on.get(e);\n  if (!l) return;\n  let f = [];\n  if (t === 'clear') f = [...l.values()];\n  else if (n === 'length' && I(e)) {\n    const u = Number(s);\n    l.forEach((d, h) => {\n      (h === 'length' || !Be(h) && h >= u) && f.push(d);\n    });\n  } else {switch (n !== void 0 && f.push(l.get(n)), t) {\n      case 'add':\n        I(e)\n          ? bn(n) && f.push(l.get('length'))\n          : (f.push(l.get(Ve)), ze(e) && f.push(l.get(ln)));\n        break;\n      case 'delete':\n        I(e) || (f.push(l.get(Ve)), ze(e) && f.push(l.get(ln)));\n        break;\n      case 'set':\n        ze(e) && f.push(l.get(Ve));\n        break;\n    }}\n  wn();\n  for (const u of f) u && Fs(u, 4);\n  En();\n}\nconst Dr = gn('__proto__,__v_isRef,__isVue'),\n  Hs = new Set(\n    Object.getOwnPropertyNames(Symbol).filter((e) =>\n      e !== 'arguments' && e !== 'caller'\n    ).map((e) => Symbol[e]).filter(Be),\n  ),\n  Gn = Br();\nfunction Br() {\n  const e = {};\n  return ['includes', 'indexOf', 'lastIndexOf'].forEach((t) => {\n    e[t] = function (...n) {\n      const s = F(this);\n      for (let i = 0, l = this.length; i < l; i++) te(s, 'get', i + '');\n      const r = s[t](...n);\n      return r === -1 || r === !1 ? s[t](...n.map(F)) : r;\n    };\n  }),\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((t) => {\n      e[t] = function (...n) {\n        Ae(), wn();\n        const s = F(this)[t].apply(this, n);\n        return En(), Me(), s;\n      };\n    }),\n    e;\n}\nfunction Kr(e) {\n  Be(e) || (e = String(e));\n  const t = F(this);\n  return te(t, 'has', e), t.hasOwnProperty(e);\n}\nclass Ns {\n  constructor(t = !1, n = !1) {\n    this._isReadonly = t, this._isShallow = n;\n  }\n  get(t, n, s) {\n    const r = this._isReadonly, i = this._isShallow;\n    if (n === '__v_isReactive') return !r;\n    if (n === '__v_isReadonly') return r;\n    if (n === '__v_isShallow') return i;\n    if (n === '__v_raw') {\n      return s === (r ? i ? ni : Vs : i ? Us : $s).get(t) ||\n          Object.getPrototypeOf(t) === Object.getPrototypeOf(s)\n        ? t\n        : void 0;\n    }\n    const l = I(t);\n    if (!r) {\n      if (l && A(Gn, n)) return Reflect.get(Gn, n, s);\n      if (n === 'hasOwnProperty') return Kr;\n    }\n    const f = Reflect.get(t, n, s);\n    return (Be(n) ? Hs.has(n) : Dr(n)) || (r || te(t, 'get', n), i)\n      ? f\n      : ne(f)\n      ? l && bn(n) ? f : f.value\n      : D(f)\n      ? r ? Ds(f) : Sn(f)\n      : f;\n  }\n}\nclass js extends Ns {\n  constructor(t = !1) {\n    super(!1, t);\n  }\n  set(t, n, s, r) {\n    let i = t[n];\n    if (!this._isShallow) {\n      const u = lt(i);\n      if (!Pt(s) && !lt(s) && (i = F(i), s = F(s)), !I(t) && ne(i) && !ne(s)) {\n        return u ? !1 : (i.value = s, !0);\n      }\n    }\n    const l = I(t) && bn(n) ? Number(n) < t.length : A(t, n),\n      f = Reflect.set(t, n, s, r);\n    return t === F(r) &&\n      (l ? Re(s, i) && ve(t, 'set', n, s) : ve(t, 'add', n, s)),\n      f;\n  }\n  deleteProperty(t, n) {\n    const s = A(t, n);\n    t[n];\n    const r = Reflect.deleteProperty(t, n);\n    return r && s && ve(t, 'delete', n, void 0), r;\n  }\n  has(t, n) {\n    const s = Reflect.has(t, n);\n    return (!Be(n) || !Hs.has(n)) && te(t, 'has', n), s;\n  }\n  ownKeys(t) {\n    return te(t, 'iterate', I(t) ? 'length' : Ve), Reflect.ownKeys(t);\n  }\n}\nclass Wr extends Ns {\n  constructor(t = !1) {\n    super(!0, t);\n  }\n  set(t, n) {\n    return !0;\n  }\n  deleteProperty(t, n) {\n    return !0;\n  }\n}\nconst qr = new js(), zr = new Wr(), Gr = new js(!0);\nconst Cn = (e) => e, Nt = (e) => Reflect.getPrototypeOf(e);\nfunction bt(e, t, n = !1, s = !1) {\n  e = e.__v_raw;\n  const r = F(e), i = F(t);\n  n || (Re(t, i) && te(r, 'get', t), te(r, 'get', i));\n  const { has: l } = Nt(r), f = s ? Cn : n ? Tn : ct;\n  if (l.call(r, t)) return f(e.get(t));\n  if (l.call(r, i)) return f(e.get(i));\n  e !== r && e.get(t);\n}\nfunction yt(e, t = !1) {\n  const n = this.__v_raw, s = F(n), r = F(e);\n  return t || (Re(e, r) && te(s, 'has', e), te(s, 'has', r)),\n    e === r ? n.has(e) : n.has(e) || n.has(r);\n}\nfunction xt(e, t = !1) {\n  return e = e.__v_raw,\n    !t && te(F(e), 'iterate', Ve),\n    Reflect.get(e, 'size', e);\n}\nfunction Jn(e) {\n  e = F(e);\n  const t = F(this);\n  return Nt(t).has.call(t, e) || (t.add(e), ve(t, 'add', e, e)), this;\n}\nfunction Yn(e, t) {\n  t = F(t);\n  const n = F(this), { has: s, get: r } = Nt(n);\n  let i = s.call(n, e);\n  i || (e = F(e), i = s.call(n, e));\n  const l = r.call(n, e);\n  return n.set(e, t),\n    i ? Re(t, l) && ve(n, 'set', e, t) : ve(n, 'add', e, t),\n    this;\n}\nfunction Zn(e) {\n  const t = F(this), { has: n, get: s } = Nt(t);\n  let r = n.call(t, e);\n  r || (e = F(e), r = n.call(t, e)), s && s.call(t, e);\n  const i = t.delete(e);\n  return r && ve(t, 'delete', e, void 0), i;\n}\nfunction Xn() {\n  const e = F(this), t = e.size !== 0, n = e.clear();\n  return t && ve(e, 'clear', void 0, void 0), n;\n}\nfunction vt(e, t) {\n  return function (s, r) {\n    const i = this, l = i.__v_raw, f = F(l), u = t ? Cn : e ? Tn : ct;\n    return !e && te(f, 'iterate', Ve),\n      l.forEach((d, h) => s.call(r, u(d), u(h), i));\n  };\n}\nfunction wt(e, t, n) {\n  return function (...s) {\n    const r = this.__v_raw,\n      i = F(r),\n      l = ze(i),\n      f = e === 'entries' || e === Symbol.iterator && l,\n      u = e === 'keys' && l,\n      d = r[e](...s),\n      h = n ? Cn : t ? Tn : ct;\n    return !t && te(i, 'iterate', u ? ln : Ve), {\n      next() {\n        const { value: x, done: E } = d.next();\n        return E\n          ? { value: x, done: E }\n          : { value: f ? [h(x[0]), h(x[1])] : h(x), done: E };\n      },\n      [Symbol.iterator]() {\n        return this;\n      },\n    };\n  };\n}\nfunction Ee(e) {\n  return function (...t) {\n    return e === 'delete' ? !1 : e === 'clear' ? void 0 : this;\n  };\n}\nfunction Jr() {\n  const e = {\n      get(i) {\n        return bt(this, i);\n      },\n      get size() {\n        return xt(this);\n      },\n      has: yt,\n      add: Jn,\n      set: Yn,\n      delete: Zn,\n      clear: Xn,\n      forEach: vt(!1, !1),\n    },\n    t = {\n      get(i) {\n        return bt(this, i, !1, !0);\n      },\n      get size() {\n        return xt(this);\n      },\n      has: yt,\n      add: Jn,\n      set: Yn,\n      delete: Zn,\n      clear: Xn,\n      forEach: vt(!1, !0),\n    },\n    n = {\n      get(i) {\n        return bt(this, i, !0);\n      },\n      get size() {\n        return xt(this, !0);\n      },\n      has(i) {\n        return yt.call(this, i, !0);\n      },\n      add: Ee('add'),\n      set: Ee('set'),\n      delete: Ee('delete'),\n      clear: Ee('clear'),\n      forEach: vt(!0, !1),\n    },\n    s = {\n      get(i) {\n        return bt(this, i, !0, !0);\n      },\n      get size() {\n        return xt(this, !0);\n      },\n      has(i) {\n        return yt.call(this, i, !0);\n      },\n      add: Ee('add'),\n      set: Ee('set'),\n      delete: Ee('delete'),\n      clear: Ee('clear'),\n      forEach: vt(!0, !0),\n    };\n  return ['keys', 'values', 'entries', Symbol.iterator].forEach((i) => {\n    e[i] = wt(i, !1, !1),\n      n[i] = wt(i, !0, !1),\n      t[i] = wt(i, !1, !0),\n      s[i] = wt(i, !0, !0);\n  }),\n    [e, n, t, s];\n}\nconst [Yr, Zr, Xr, Qr] = Jr();\nfunction On(e, t) {\n  const n = t ? e ? Qr : Xr : e ? Zr : Yr;\n  return (s, r, i) =>\n    r === '__v_isReactive'\n      ? !e\n      : r === '__v_isReadonly'\n      ? e\n      : r === '__v_raw'\n      ? s\n      : Reflect.get(A(n, r) && r in s ? n : s, r, i);\n}\nconst kr = { get: On(!1, !1) },\n  ei = { get: On(!1, !0) },\n  ti = { get: On(!0, !1) };\nconst $s = new WeakMap(),\n  Us = new WeakMap(),\n  Vs = new WeakMap(),\n  ni = new WeakMap();\nfunction si(e) {\n  switch (e) {\n    case 'Object':\n    case 'Array':\n      return 1;\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction ri(e) {\n  return e.__v_skip || !Object.isExtensible(e) ? 0 : si(Ir(e));\n}\nfunction Sn(e) {\n  return lt(e) ? e : In(e, !1, qr, kr, $s);\n}\nfunction ii(e) {\n  return In(e, !1, Gr, ei, Us);\n}\nfunction Ds(e) {\n  return In(e, !0, zr, ti, Vs);\n}\nfunction In(e, t, n, s, r) {\n  if (!D(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;\n  const i = r.get(e);\n  if (i) return i;\n  const l = ri(e);\n  if (l === 0) return e;\n  const f = new Proxy(e, l === 2 ? s : n);\n  return r.set(e, f), f;\n}\nfunction st(e) {\n  return lt(e) ? st(e.__v_raw) : !!(e && e.__v_isReactive);\n}\nfunction lt(e) {\n  return !!(e && e.__v_isReadonly);\n}\nfunction Pt(e) {\n  return !!(e && e.__v_isShallow);\n}\nfunction Bs(e) {\n  return e ? !!e.__v_raw : !1;\n}\nfunction F(e) {\n  const t = e && e.__v_raw;\n  return t ? F(t) : e;\n}\nfunction oi(e) {\n  return Object.isExtensible(e) && Ss(e, '__v_skip', !0), e;\n}\nconst ct = (e) => D(e) ? Sn(e) : e, Tn = (e) => D(e) ? Ds(e) : e;\nclass Ks {\n  constructor(t, n, s, r) {\n    this.getter = t,\n      this._setter = n,\n      this.dep = void 0,\n      this.__v_isRef = !0,\n      this.__v_isReadonly = !1,\n      this.effect = new vn(\n        () => t(this._value),\n        () => Ct(this, this.effect._dirtyLevel === 2 ? 2 : 3),\n      ),\n      this.effect.computed = this,\n      this.effect.active = this._cacheable = !r,\n      this.__v_isReadonly = s;\n  }\n  get value() {\n    const t = F(this);\n    return (!t._cacheable || t.effect.dirty) &&\n      Re(t._value, t._value = t.effect.run()) && Ct(t, 4),\n      Ws(t),\n      t.effect._dirtyLevel >= 2 && Ct(t, 2),\n      t._value;\n  }\n  set value(t) {\n    this._setter(t);\n  }\n  get _dirty() {\n    return this.effect.dirty;\n  }\n  set _dirty(t) {\n    this.effect.dirty = t;\n  }\n}\nfunction li(e, t, n = !1) {\n  let s, r;\n  const i = P(e);\n  return i ? (s = e, r = oe) : (s = e.get, r = e.set), new Ks(s, r, i || !r, n);\n}\nfunction Ws(e) {\n  var t;\n  Ie && Ue &&\n    (e = F(e),\n      Ms(\n        Ue,\n        (t = e.dep) != null\n          ? t\n          : e.dep = Ls(() => e.dep = void 0, e instanceof Ks ? e : void 0),\n      ));\n}\nfunction Ct(e, t = 4, n) {\n  e = F(e);\n  const s = e.dep;\n  s && Fs(s, t);\n}\nfunction ne(e) {\n  return !!(e && e.__v_isRef === !0);\n}\nfunction ci(e) {\n  return fi(e, !1);\n}\nfunction fi(e, t) {\n  return ne(e) ? e : new ui(e, t);\n}\nclass ui {\n  constructor(t, n) {\n    this.__v_isShallow = n,\n      this.dep = void 0,\n      this.__v_isRef = !0,\n      this._rawValue = n ? t : F(t),\n      this._value = n ? t : ct(t);\n  }\n  get value() {\n    return Ws(this), this._value;\n  }\n  set value(t) {\n    const n = this.__v_isShallow || Pt(t) || lt(t);\n    t = n ? t : F(t),\n      Re(t, this._rawValue) &&\n      (this._rawValue = t, this._value = n ? t : ct(t), Ct(this, 4));\n  }\n}\nfunction ai(e) {\n  return ne(e) ? e.value : e;\n}\nconst di = {\n  get: (e, t, n) => ai(Reflect.get(e, t, n)),\n  set: (e, t, n, s) => {\n    const r = e[t];\n    return ne(r) && !ne(n) ? (r.value = n, !0) : Reflect.set(e, t, n, s);\n  },\n};\nfunction qs(e) {\n  return st(e) ? e : new Proxy(e, di);\n} /**\n * @vue/runtime-core v3.4.26\n * (c) 2018-present Yuxi (Evan) You and Vue contributors\n * @license MIT\n */\n\nfunction Te(e, t, n, s) {\n  try {\n    return s ? e(...s) : e();\n  } catch (r) {\n    jt(r, t, n);\n  }\n}\nfunction ae(e, t, n, s) {\n  if (P(e)) {\n    const r = Te(e, t, n, s);\n    return r && ws(r) && r.catch((i) => {\n      jt(i, t, n);\n    }),\n      r;\n  }\n  if (I(e)) {\n    const r = [];\n    for (let i = 0; i < e.length; i++) r.push(ae(e[i], t, n, s));\n    return r;\n  }\n}\nfunction jt(e, t, n, s = !0) {\n  const r = t ? t.vnode : null;\n  if (t) {\n    let i = t.parent;\n    const l = t.proxy, f = `https://vuejs.org/error-reference/#runtime-${n}`;\n    for (; i;) {\n      const d = i.ec;\n      if (d) {\n        for (let h = 0; h < d.length; h++) if (d[h](e, l, f) === !1) return;\n      }\n      i = i.parent;\n    }\n    const u = t.appContext.config.errorHandler;\n    if (u) {\n      Ae(), Te(u, null, 10, [e, l, f]), Me();\n      return;\n    }\n  }\n  hi(e, n, r, s);\n}\nfunction hi(e, t, n, s = !0) {\n  console.error(e);\n}\nlet ft = !1, cn = !1;\nconst Y = [];\nlet me = 0;\nconst Ge = [];\nlet Ce = null, $e = 0;\nconst zs = Promise.resolve();\nlet Pn = null;\nfunction pi(e) {\n  const t = Pn || zs;\n  return e ? t.then(this ? e.bind(this) : e) : t;\n}\nfunction gi(e) {\n  let t = me + 1, n = Y.length;\n  for (; t < n;) {\n    const s = t + n >>> 1, r = Y[s], i = ut(r);\n    i < e || i === e && r.pre ? t = s + 1 : n = s;\n  }\n  return t;\n}\nfunction Rn(e) {\n  (!Y.length || !Y.includes(e, ft && e.allowRecurse ? me + 1 : me)) &&\n    (e.id == null ? Y.push(e) : Y.splice(gi(e.id), 0, e), Gs());\n}\nfunction Gs() {\n  !ft && !cn && (cn = !0, Pn = zs.then(Ys));\n}\nfunction _i(e) {\n  const t = Y.indexOf(e);\n  t > me && Y.splice(t, 1);\n}\nfunction mi(e) {\n  I(e)\n    ? Ge.push(...e)\n    : (!Ce || !Ce.includes(e, e.allowRecurse ? $e + 1 : $e)) && Ge.push(e),\n    Gs();\n}\nfunction Qn(e, t, n = ft ? me + 1 : 0) {\n  for (; n < Y.length; n++) {\n    const s = Y[n];\n    if (s && s.pre) {\n      if (e && s.id !== e.uid) continue;\n      Y.splice(n, 1), n--, s();\n    }\n  }\n}\nfunction Js(e) {\n  if (Ge.length) {\n    const t = [...new Set(Ge)].sort((n, s) => ut(n) - ut(s));\n    if (Ge.length = 0, Ce) {\n      Ce.push(...t);\n      return;\n    }\n    for (Ce = t, $e = 0; $e < Ce.length; $e++) Ce[$e]();\n    Ce = null, $e = 0;\n  }\n}\nconst ut = (e) => e.id == null ? 1 / 0 : e.id,\n  bi = (e, t) => {\n    const n = ut(e) - ut(t);\n    if (n === 0) {\n      if (e.pre && !t.pre) return -1;\n      if (t.pre && !e.pre) return 1;\n    }\n    return n;\n  };\nfunction Ys(e) {\n  cn = !1, ft = !0, Y.sort(bi);\n  try {\n    for (me = 0; me < Y.length; me++) {\n      const t = Y[me];\n      t && t.active !== !1 && Te(t, null, 14);\n    }\n  } finally {\n    me = 0,\n      Y.length = 0,\n      Js(),\n      ft = !1,\n      Pn = null,\n      (Y.length || Ge.length) && Ys();\n  }\n}\nfunction yi(e, t, ...n) {\n  if (e.isUnmounted) return;\n  const s = e.vnode.props || U;\n  let r = n;\n  const i = t.startsWith('update:'), l = i && t.slice(7);\n  if (l && l in s) {\n    const h = `${l === 'modelValue' ? 'model' : l}Modifiers`,\n      { number: x, trim: E } = s[h] || U;\n    E && (r = n.map((T) => G(T) ? T.trim() : T)), x && (r = n.map(Rr));\n  }\n  let f, u = s[f = Gt(t)] || s[f = Gt(Je(t))];\n  !u && i && (u = s[f = Gt(Ze(t))]), u && ae(u, e, 6, r);\n  const d = s[f + 'Once'];\n  if (d) {\n    if (!e.emitted) e.emitted = {};\n    else if (e.emitted[f]) return;\n    e.emitted[f] = !0, ae(d, e, 6, r);\n  }\n}\nfunction Zs(e, t, n = !1) {\n  const s = t.emitsCache, r = s.get(e);\n  if (r !== void 0) return r;\n  const i = e.emits;\n  let l = {}, f = !1;\n  if (!P(e)) {\n    const u = (d) => {\n      const h = Zs(d, t, !0);\n      h && (f = !0, z(l, h));\n    };\n    !n && t.mixins.length && t.mixins.forEach(u),\n      e.extends && u(e.extends),\n      e.mixins && e.mixins.forEach(u);\n  }\n  return !i && !f\n    ? (D(e) && s.set(e, null), null)\n    : (I(i) ? i.forEach((u) => l[u] = null) : z(l, i), D(e) && s.set(e, l), l);\n}\nfunction $t(e, t) {\n  return !e || !Ft(t)\n    ? !1\n    : (t = t.slice(2).replace(/Once$/, ''),\n      A(e, t[0].toLowerCase() + t.slice(1)) || A(e, Ze(t)) || A(e, t));\n}\nlet be = null, Ut = null;\nfunction Rt(e) {\n  const t = be;\n  return be = e, Ut = e && e.type.__scopeId || null, t;\n}\nfunction Xs(e) {\n  Ut = e;\n}\nfunction Qs() {\n  Ut = null;\n}\nfunction xi(e, t = be, n) {\n  if (!t || e._n) return e;\n  const s = (...r) => {\n    s._d && cs(-1);\n    const i = Rt(t);\n    let l;\n    try {\n      l = e(...r);\n    } finally {\n      Rt(i), s._d && cs(1);\n    }\n    return l;\n  };\n  return s._n = !0, s._c = !0, s._d = !0, s;\n}\nfunction Zt(e) {\n  const {\n      type: t,\n      vnode: n,\n      proxy: s,\n      withProxy: r,\n      propsOptions: [i],\n      slots: l,\n      attrs: f,\n      emit: u,\n      render: d,\n      renderCache: h,\n      props: x,\n      data: E,\n      setupState: T,\n      ctx: B,\n      inheritAttrs: L,\n    } = e,\n    se = Rt(e);\n  let K, J;\n  try {\n    if (n.shapeFlag & 4) {\n      const W = r || s, ie = W;\n      K = _e(d.call(ie, W, h, x, T, E, B)), J = f;\n    } else {\n      const W = t;\n      K = _e(W.length > 1 ? W(x, { attrs: f, slots: l, emit: u }) : W(x, null)),\n        J = t.props ? f : vi(f);\n    }\n  } catch (W) {\n    ot.length = 0, jt(W, e, 1), K = Pe(at);\n  }\n  let N = K;\n  if (J && L !== !1) {\n    const W = Object.keys(J), { shapeFlag: ie } = N;\n    W.length && ie & 7 &&\n      (i && W.some(_n) && (J = wi(J, i)), N = Ye(N, J, !1, !0));\n  }\n  return n.dirs &&\n    (N = Ye(N, null, !1, !0), N.dirs = N.dirs ? N.dirs.concat(n.dirs) : n.dirs),\n    n.transition && (N.transition = n.transition),\n    K = N,\n    Rt(se),\n    K;\n}\nconst vi = (e) => {\n    let t;\n    for (const n in e) {\n      (n === 'class' || n === 'style' || Ft(n)) && ((t || (t = {}))[n] = e[n]);\n    }\n    return t;\n  },\n  wi = (e, t) => {\n    const n = {};\n    for (const s in e) (!_n(s) || !(s.slice(9) in t)) && (n[s] = e[s]);\n    return n;\n  };\nfunction Ei(e, t, n) {\n  const { props: s, children: r, component: i } = e,\n    { props: l, children: f, patchFlag: u } = t,\n    d = i.emitsOptions;\n  if (t.dirs || t.transition) return !0;\n  if (n && u >= 0) {\n    if (u & 1024) return !0;\n    if (u & 16) return s ? kn(s, l, d) : !!l;\n    if (u & 8) {\n      const h = t.dynamicProps;\n      for (let x = 0; x < h.length; x++) {\n        const E = h[x];\n        if (l[E] !== s[E] && !$t(d, E)) return !0;\n      }\n    }\n  } else {return (r || f) && (!f || !f.$stable)\n      ? !0\n      : s === l\n      ? !1\n      : s\n      ? l ? kn(s, l, d) : !0\n      : !!l;}\n  return !1;\n}\nfunction kn(e, t, n) {\n  const s = Object.keys(t);\n  if (s.length !== Object.keys(e).length) return !0;\n  for (let r = 0; r < s.length; r++) {\n    const i = s[r];\n    if (t[i] !== e[i] && !$t(n, i)) return !0;\n  }\n  return !1;\n}\nfunction Ci({ vnode: e, parent: t }, n) {\n  for (; t;) {\n    const s = t.subTree;\n    if (s.suspense && s.suspense.activeBranch === e && (s.el = e.el), s === e) {\n      (e = t.vnode).el = n, t = t.parent;\n    } else break;\n  }\n}\nconst Oi = Symbol.for('v-ndc'), Si = (e) => e.__isSuspense;\nfunction Ii(e, t) {\n  t && t.pendingBranch\n    ? I(e) ? t.effects.push(...e) : t.effects.push(e)\n    : mi(e);\n}\nconst Ti = Symbol.for('v-scx'), Pi = () => St(Ti), Et = {};\nfunction Xt(e, t, n) {\n  return ks(e, t, n);\n}\nfunction ks(\n  e,\n  t,\n  { immediate: n, deep: s, flush: r, once: i, onTrack: l, onTrigger: f } = U,\n) {\n  if (t && i) {\n    const M = t;\n    t = (...ye) => {\n      M(...ye), ie();\n    };\n  }\n  const u = k, d = (M) => s === !0 ? M : We(M, s === !1 ? 1 : void 0);\n  let h, x = !1, E = !1;\n  if (\n    ne(e)\n      ? (h = () => e.value, x = Pt(e))\n      : st(e)\n      ? (h = () => d(e), x = !0)\n      : I(e)\n      ? (E = !0,\n        x = e.some((M) => st(M) || Pt(M)),\n        h = () =>\n          e.map((M) => {\n            if (ne(M)) return M.value;\n            if (st(M)) return d(M);\n            if (P(M)) return Te(M, u, 2);\n          }))\n      : P(e)\n      ? t ? h = () => Te(e, u, 2) : h = () => (T && T(), ae(e, u, 3, [B]))\n      : h = oe, t && s\n  ) {\n    const M = h;\n    h = () => We(M());\n  }\n  let T,\n    B = (M) => {\n      T = N.onStop = () => {\n        Te(M, u, 4), T = N.onStop = void 0;\n      };\n    },\n    L;\n  if (Bt) {\n    if (\n      B = oe,\n        t ? n && ae(t, u, 3, [h(), E ? [] : void 0, B]) : h(),\n        r === 'sync'\n    ) {\n      const M = Pi();\n      L = M.__watcherHandles || (M.__watcherHandles = []);\n    } else return oe;\n  }\n  let se = E ? new Array(e.length).fill(Et) : Et;\n  const K = () => {\n    if (!(!N.active || !N.dirty)) {\n      if (t) {\n        const M = N.run();\n        (s || x || (E ? M.some((ye, de) => Re(ye, se[de])) : Re(M, se))) &&\n          (T && T(),\n            ae(t, u, 3, [\n              M,\n              se === Et ? void 0 : E && se[0] === Et ? [] : se,\n              B,\n            ]),\n            se = M);\n      } else N.run();\n    }\n  };\n  K.allowRecurse = !!t;\n  let J;\n  r === 'sync'\n    ? J = K\n    : r === 'post'\n    ? J = () => ee(K, u && u.suspense)\n    : (K.pre = !0, u && (K.id = u.uid), J = () => Rn(K));\n  const N = new vn(h, oe, J),\n    W = Ur(),\n    ie = () => {\n      N.stop(), W && mn(W.effects, N);\n    };\n  return t\n    ? n ? K() : se = N.run()\n    : r === 'post'\n    ? ee(N.run.bind(N), u && u.suspense)\n    : N.run(),\n    L && L.push(ie),\n    ie;\n}\nfunction Ri(e, t, n) {\n  const s = this.proxy,\n    r = G(e) ? e.includes('.') ? er(s, e) : () => s[e] : e.bind(s, s);\n  let i;\n  P(t) ? i = t : (i = t.handler, n = t);\n  const l = ht(this), f = ks(r, i.bind(s), n);\n  return l(), f;\n}\nfunction er(e, t) {\n  const n = t.split('.');\n  return () => {\n    let s = e;\n    for (let r = 0; r < n.length && s; r++) s = s[n[r]];\n    return s;\n  };\n}\nfunction We(e, t = 1 / 0, n) {\n  if (t <= 0 || !D(e) || e.__v_skip || (n = n || new Set(), n.has(e))) return e;\n  if (n.add(e), t--, ne(e)) We(e.value, t, n);\n  else if (I(e)) for (let s = 0; s < e.length; s++) We(e[s], t, n);\n  else if (vs(e) || ze(e)) {\n    e.forEach((s) => {\n      We(s, t, n);\n    });\n  } else if (Cs(e)) for (const s in e) We(e[s], t, n);\n  return e;\n}\nfunction Ne(e, t, n, s) {\n  const r = e.dirs, i = t && t.dirs;\n  for (let l = 0; l < r.length; l++) {\n    const f = r[l];\n    i && (f.oldValue = i[l].value);\n    let u = f.dir[s];\n    u && (Ae(), ae(u, n, 8, [e.el, f, e, t]), Me());\n  }\n} /*! #__NO_SIDE_EFFECTS__ */\nfunction tr(e, t) {\n  return P(e) ? z({ name: e.name }, t, { setup: e }) : e;\n}\nconst Ot = (e) => !!e.type.__asyncLoader, nr = (e) => e.type.__isKeepAlive;\nfunction Ai(e, t) {\n  sr(e, 'a', t);\n}\nfunction Mi(e, t) {\n  sr(e, 'da', t);\n}\nfunction sr(e, t, n = k) {\n  const s = e.__wdc || (e.__wdc = () => {\n    let r = n;\n    for (; r;) {\n      if (r.isDeactivated) return;\n      r = r.parent;\n    }\n    return e();\n  });\n  if (Vt(t, s, n), n) {\n    let r = n.parent;\n    for (; r && r.parent;) nr(r.parent.vnode) && Fi(s, t, n, r), r = r.parent;\n  }\n}\nfunction Fi(e, t, n, s) {\n  const r = Vt(t, e, s, !0);\n  rr(() => {\n    mn(s[t], r);\n  }, n);\n}\nfunction Vt(e, t, n = k, s = !1) {\n  if (n) {\n    const r = n[e] || (n[e] = []),\n      i = t.__weh || (t.__weh = (...l) => {\n        if (n.isUnmounted) return;\n        Ae();\n        const f = ht(n), u = ae(t, n, e, l);\n        return f(), Me(), u;\n      });\n    return s ? r.unshift(i) : r.push(i), i;\n  }\n}\nconst we = (e) => (t, n = k) =>\n    (!Bt || e === 'sp') && Vt(e, (...s) => t(...s), n),\n  Li = we('bm'),\n  Hi = we('m'),\n  Ni = we('bu'),\n  ji = we('u'),\n  $i = we('bum'),\n  rr = we('um'),\n  Ui = we('sp'),\n  Vi = we('rtg'),\n  Di = we('rtc');\nfunction Bi(e, t = k) {\n  Vt('ec', e, t);\n}\nconst fn = (e) => e ? xr(e) ? Ln(e) || e.proxy : fn(e.parent) : null,\n  rt = z(Object.create(null), {\n    $: (e) => e,\n    $el: (e) => e.vnode.el,\n    $data: (e) => e.data,\n    $props: (e) => e.props,\n    $attrs: (e) => e.attrs,\n    $slots: (e) => e.slots,\n    $refs: (e) => e.refs,\n    $parent: (e) => fn(e.parent),\n    $root: (e) => fn(e.root),\n    $emit: (e) => e.emit,\n    $options: (e) => An(e),\n    $forceUpdate: (e) =>\n      e.f || (e.f = () => {\n        e.effect.dirty = !0, Rn(e.update);\n      }),\n    $nextTick: (e) => e.n || (e.n = pi.bind(e.proxy)),\n    $watch: (e) => Ri.bind(e),\n  }),\n  Qt = (e, t) => e !== U && !e.__isScriptSetup && A(e, t),\n  Ki = {\n    get({ _: e }, t) {\n      if (t === '__v_skip') return !0;\n      const {\n        ctx: n,\n        setupState: s,\n        data: r,\n        props: i,\n        accessCache: l,\n        type: f,\n        appContext: u,\n      } = e;\n      let d;\n      if (t[0] !== '$') {\n        const T = l[t];\n        if (T !== void 0) {\n          switch (T) {\n            case 1:\n              return s[t];\n            case 2:\n              return r[t];\n            case 4:\n              return n[t];\n            case 3:\n              return i[t];\n          }\n        } else {\n          if (Qt(s, t)) return l[t] = 1, s[t];\n          if (r !== U && A(r, t)) return l[t] = 2, r[t];\n          if ((d = e.propsOptions[0]) && A(d, t)) return l[t] = 3, i[t];\n          if (n !== U && A(n, t)) return l[t] = 4, n[t];\n          un && (l[t] = 0);\n        }\n      }\n      const h = rt[t];\n      let x, E;\n      if (h) return t === '$attrs' && te(e.attrs, 'get', ''), h(e);\n      if ((x = f.__cssModules) && (x = x[t])) return x;\n      if (n !== U && A(n, t)) return l[t] = 4, n[t];\n      if (E = u.config.globalProperties, A(E, t)) return E[t];\n    },\n    set({ _: e }, t, n) {\n      const { data: s, setupState: r, ctx: i } = e;\n      return Qt(r, t)\n        ? (r[t] = n, !0)\n        : s !== U && A(s, t)\n        ? (s[t] = n, !0)\n        : A(e.props, t) || t[0] === '$' && t.slice(1) in e\n        ? !1\n        : (i[t] = n, !0);\n    },\n    has(\n      {\n        _: {\n          data: e,\n          setupState: t,\n          accessCache: n,\n          ctx: s,\n          appContext: r,\n          propsOptions: i,\n        },\n      },\n      l,\n    ) {\n      let f;\n      return !!n[l] || e !== U && A(e, l) || Qt(t, l) ||\n        (f = i[0]) && A(f, l) || A(s, l) || A(rt, l) ||\n        A(r.config.globalProperties, l);\n    },\n    defineProperty(e, t, n) {\n      return n.get != null\n        ? e._.accessCache[t] = 0\n        : A(n, 'value') && this.set(e, t, n.value, null),\n        Reflect.defineProperty(e, t, n);\n    },\n  };\nfunction es(e) {\n  return I(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e;\n}\nlet un = !0;\nfunction Wi(e) {\n  const t = An(e), n = e.proxy, s = e.ctx;\n  un = !1, t.beforeCreate && ts(t.beforeCreate, e, 'bc');\n  const {\n    data: r,\n    computed: i,\n    methods: l,\n    watch: f,\n    provide: u,\n    inject: d,\n    created: h,\n    beforeMount: x,\n    mounted: E,\n    beforeUpdate: T,\n    updated: B,\n    activated: L,\n    deactivated: se,\n    beforeDestroy: K,\n    beforeUnmount: J,\n    destroyed: N,\n    unmounted: W,\n    render: ie,\n    renderTracked: M,\n    renderTriggered: ye,\n    errorCaptured: de,\n    serverPrefetch: Wt,\n    expose: Fe,\n    inheritAttrs: Xe,\n    components: pt,\n    directives: gt,\n    filters: qt,\n  } = t;\n  if (d && qi(d, s, null), l) {\n    for (const V in l) {\n      const j = l[V];\n      P(j) && (s[V] = j.bind(n));\n    }\n  }\n  if (r) {\n    const V = r.call(n, n);\n    D(V) && (e.data = Sn(V));\n  }\n  if (un = !0, i) {\n    for (const V in i) {\n      const j = i[V],\n        Le = P(j) ? j.bind(n, n) : P(j.get) ? j.get.bind(n, n) : oe,\n        _t = !P(j) && P(j.set) ? j.set.bind(n) : oe,\n        He = Eo({ get: Le, set: _t });\n      Object.defineProperty(s, V, {\n        enumerable: !0,\n        configurable: !0,\n        get: () => He.value,\n        set: (he) => He.value = he,\n      });\n    }\n  }\n  if (f) for (const V in f) ir(f[V], s, n, V);\n  if (u) {\n    const V = P(u) ? u.call(n) : u;\n    Reflect.ownKeys(V).forEach((j) => {\n      Xi(j, V[j]);\n    });\n  }\n  h && ts(h, e, 'c');\n  function X(V, j) {\n    I(j) ? j.forEach((Le) => V(Le.bind(n))) : j && V(j.bind(n));\n  }\n  if (\n    X(Li, x),\n      X(Hi, E),\n      X(Ni, T),\n      X(ji, B),\n      X(Ai, L),\n      X(Mi, se),\n      X(Bi, de),\n      X(Di, M),\n      X(Vi, ye),\n      X($i, J),\n      X(rr, W),\n      X(Ui, Wt),\n      I(Fe)\n  ) {\n    if (Fe.length) {\n      const V = e.exposed || (e.exposed = {});\n      Fe.forEach((j) => {\n        Object.defineProperty(V, j, {\n          get: () => n[j],\n          set: (Le) => n[j] = Le,\n        });\n      });\n    } else e.exposed || (e.exposed = {});\n  }\n  ie && e.render === oe && (e.render = ie),\n    Xe != null && (e.inheritAttrs = Xe),\n    pt && (e.components = pt),\n    gt && (e.directives = gt);\n}\nfunction qi(e, t, n = oe) {\n  I(e) && (e = an(e));\n  for (const s in e) {\n    const r = e[s];\n    let i;\n    D(r)\n      ? 'default' in r\n        ? i = St(r.from || s, r.default, !0)\n        : i = St(r.from || s)\n      : i = St(r),\n      ne(i)\n        ? Object.defineProperty(t, s, {\n          enumerable: !0,\n          configurable: !0,\n          get: () => i.value,\n          set: (l) => i.value = l,\n        })\n        : t[s] = i;\n  }\n}\nfunction ts(e, t, n) {\n  ae(I(e) ? e.map((s) => s.bind(t.proxy)) : e.bind(t.proxy), t, n);\n}\nfunction ir(e, t, n, s) {\n  const r = s.includes('.') ? er(n, s) : () => n[s];\n  if (G(e)) {\n    const i = t[e];\n    P(i) && Xt(r, i);\n  } else if (P(e)) Xt(r, e.bind(n));\n  else if (D(e)) {\n    if (I(e)) e.forEach((i) => ir(i, t, n, s));\n    else {\n      const i = P(e.handler) ? e.handler.bind(n) : t[e.handler];\n      P(i) && Xt(r, i, e);\n    }\n  }\n}\nfunction An(e) {\n  const t = e.type,\n    { mixins: n, extends: s } = t,\n    { mixins: r, optionsCache: i, config: { optionMergeStrategies: l } } =\n      e.appContext,\n    f = i.get(t);\n  let u;\n  return f\n    ? u = f\n    : !r.length && !n && !s\n    ? u = t\n    : (u = {}, r.length && r.forEach((d) => At(u, d, l, !0)), At(u, t, l)),\n    D(t) && i.set(t, u),\n    u;\n}\nfunction At(e, t, n, s = !1) {\n  const { mixins: r, extends: i } = t;\n  i && At(e, i, n, !0), r && r.forEach((l) => At(e, l, n, !0));\n  for (const l in t) {\n    if (!(s && l === 'expose')) {\n      const f = zi[l] || n && n[l];\n      e[l] = f ? f(e[l], t[l]) : t[l];\n    }\n  }\n  return e;\n}\nconst zi = {\n  data: ns,\n  props: ss,\n  emits: ss,\n  methods: tt,\n  computed: tt,\n  beforeCreate: Q,\n  created: Q,\n  beforeMount: Q,\n  mounted: Q,\n  beforeUpdate: Q,\n  updated: Q,\n  beforeDestroy: Q,\n  beforeUnmount: Q,\n  destroyed: Q,\n  unmounted: Q,\n  activated: Q,\n  deactivated: Q,\n  errorCaptured: Q,\n  serverPrefetch: Q,\n  components: tt,\n  directives: tt,\n  watch: Ji,\n  provide: ns,\n  inject: Gi,\n};\nfunction ns(e, t) {\n  return t\n    ? e\n      ? function () {\n        return z(P(e) ? e.call(this, this) : e, P(t) ? t.call(this, this) : t);\n      }\n      : t\n    : e;\n}\nfunction Gi(e, t) {\n  return tt(an(e), an(t));\n}\nfunction an(e) {\n  if (I(e)) {\n    const t = {};\n    for (let n = 0; n < e.length; n++) t[e[n]] = e[n];\n    return t;\n  }\n  return e;\n}\nfunction Q(e, t) {\n  return e ? [...new Set([].concat(e, t))] : t;\n}\nfunction tt(e, t) {\n  return e ? z(Object.create(null), e, t) : t;\n}\nfunction ss(e, t) {\n  return e\n    ? I(e) && I(t)\n      ? [...new Set([...e, ...t])]\n      : z(Object.create(null), es(e), es(t ?? {}))\n    : t;\n}\nfunction Ji(e, t) {\n  if (!e) return t;\n  if (!t) return e;\n  const n = z(Object.create(null), e);\n  for (const s in t) n[s] = Q(e[s], t[s]);\n  return n;\n}\nfunction or() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: Or,\n      performance: !1,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: void 0,\n      warnHandler: void 0,\n      compilerOptions: {},\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: Object.create(null),\n    optionsCache: new WeakMap(),\n    propsCache: new WeakMap(),\n    emitsCache: new WeakMap(),\n  };\n}\nlet Yi = 0;\nfunction Zi(e, t) {\n  return function (s, r = null) {\n    P(s) || (s = z({}, s)), r != null && !D(r) && (r = null);\n    const i = or(), l = new WeakSet();\n    let f = !1;\n    const u = i.app = {\n      _uid: Yi++,\n      _component: s,\n      _props: r,\n      _container: null,\n      _context: i,\n      _instance: null,\n      version: Co,\n      get config() {\n        return i.config;\n      },\n      set config(d) {},\n      use(d, ...h) {\n        return l.has(d) ||\n          (d && P(d.install)\n            ? (l.add(d), d.install(u, ...h))\n            : P(d) && (l.add(d), d(u, ...h))),\n          u;\n      },\n      mixin(d) {\n        return i.mixins.includes(d) || i.mixins.push(d), u;\n      },\n      component(d, h) {\n        return h ? (i.components[d] = h, u) : i.components[d];\n      },\n      directive(d, h) {\n        return h ? (i.directives[d] = h, u) : i.directives[d];\n      },\n      mount(d, h, x) {\n        if (!f) {\n          const E = Pe(s, r);\n          return E.appContext = i,\n            x === !0 ? x = 'svg' : x === !1 && (x = void 0),\n            h && t ? t(E, d) : e(E, d, x),\n            f = !0,\n            u._container = d,\n            d.__vue_app__ = u,\n            Ln(E.component) || E.component.proxy;\n        }\n      },\n      unmount() {\n        f && (e(null, u._container), delete u._container.__vue_app__);\n      },\n      provide(d, h) {\n        return i.provides[d] = h, u;\n      },\n      runWithContext(d) {\n        const h = it;\n        it = u;\n        try {\n          return d();\n        } finally {\n          it = h;\n        }\n      },\n    };\n    return u;\n  };\n}\nlet it = null;\nfunction Xi(e, t) {\n  if (k) {\n    let n = k.provides;\n    const s = k.parent && k.parent.provides;\n    s === n && (n = k.provides = Object.create(s)), n[e] = t;\n  }\n}\nfunction St(e, t, n = !1) {\n  const s = k || be;\n  if (s || it) {\n    const r = s\n      ? s.parent == null\n        ? s.vnode.appContext && s.vnode.appContext.provides\n        : s.parent.provides\n      : it._context.provides;\n    if (r && e in r) return r[e];\n    if (arguments.length > 1) return n && P(t) ? t.call(s && s.proxy) : t;\n  }\n}\nconst lr = {},\n  cr = () => Object.create(lr),\n  fr = (e) => Object.getPrototypeOf(e) === lr;\nfunction Qi(e, t, n, s = !1) {\n  const r = {}, i = cr();\n  e.propsDefaults = Object.create(null), ur(e, t, r, i);\n  for (const l in e.propsOptions[0]) l in r || (r[l] = void 0);\n  n ? e.props = s ? r : ii(r) : e.type.props ? e.props = r : e.props = i,\n    e.attrs = i;\n}\nfunction ki(e, t, n, s) {\n  const { props: r, attrs: i, vnode: { patchFlag: l } } = e,\n    f = F(r),\n    [u] = e.propsOptions;\n  let d = !1;\n  if ((s || l > 0) && !(l & 16)) {\n    if (l & 8) {\n      const h = e.vnode.dynamicProps;\n      for (let x = 0; x < h.length; x++) {\n        let E = h[x];\n        if ($t(e.emitsOptions, E)) continue;\n        const T = t[E];\n        if (u) {\n          if (A(i, E)) T !== i[E] && (i[E] = T, d = !0);\n          else {\n            const B = Je(E);\n            r[B] = dn(u, f, B, T, e, !1);\n          }\n        } else T !== i[E] && (i[E] = T, d = !0);\n      }\n    }\n  } else {\n    ur(e, t, r, i) && (d = !0);\n    let h;\n    for (const x in f) {\n      (!t || !A(t, x) && ((h = Ze(x)) === x || !A(t, h))) &&\n        (u\n          ? n && (n[x] !== void 0 || n[h] !== void 0) &&\n            (r[x] = dn(u, f, x, void 0, e, !0))\n          : delete r[x]);\n    }\n    if (i !== f) for (const x in i) (!t || !A(t, x)) && (delete i[x], d = !0);\n  }\n  d && ve(e.attrs, 'set', '');\n}\nfunction ur(e, t, n, s) {\n  const [r, i] = e.propsOptions;\n  let l = !1, f;\n  if (t) {\n    for (let u in t) {\n      if (nt(u)) continue;\n      const d = t[u];\n      let h;\n      r && A(r, h = Je(u))\n        ? !i || !i.includes(h) ? n[h] = d : (f || (f = {}))[h] = d\n        : $t(e.emitsOptions, u) ||\n          (!(u in s) || d !== s[u]) && (s[u] = d, l = !0);\n    }\n  }\n  if (i) {\n    const u = F(n), d = f || U;\n    for (let h = 0; h < i.length; h++) {\n      const x = i[h];\n      n[x] = dn(r, u, x, d[x], e, !A(d, x));\n    }\n  }\n  return l;\n}\nfunction dn(e, t, n, s, r, i) {\n  const l = e[n];\n  if (l != null) {\n    const f = A(l, 'default');\n    if (f && s === void 0) {\n      const u = l.default;\n      if (l.type !== Function && !l.skipFactory && P(u)) {\n        const { propsDefaults: d } = r;\n        if (n in d) s = d[n];\n        else {\n          const h = ht(r);\n          s = d[n] = u.call(null, t), h();\n        }\n      } else s = u;\n    }\n    l[0] && (i && !f ? s = !1 : l[1] && (s === '' || s === Ze(n)) && (s = !0));\n  }\n  return s;\n}\nfunction ar(e, t, n = !1) {\n  const s = t.propsCache, r = s.get(e);\n  if (r) return r;\n  const i = e.props, l = {}, f = [];\n  let u = !1;\n  if (!P(e)) {\n    const h = (x) => {\n      u = !0;\n      const [E, T] = ar(x, t, !0);\n      z(l, E), T && f.push(...T);\n    };\n    !n && t.mixins.length && t.mixins.forEach(h),\n      e.extends && h(e.extends),\n      e.mixins && e.mixins.forEach(h);\n  }\n  if (!i && !u) return D(e) && s.set(e, qe), qe;\n  if (I(i)) {\n    for (let h = 0; h < i.length; h++) {\n      const x = Je(i[h]);\n      rs(x) && (l[x] = U);\n    }\n  } else if (i) {\n    for (const h in i) {\n      const x = Je(h);\n      if (rs(x)) {\n        const E = i[h], T = l[x] = I(E) || P(E) ? { type: E } : z({}, E);\n        if (T) {\n          const B = ls(Boolean, T.type), L = ls(String, T.type);\n          T[0] = B > -1,\n            T[1] = L < 0 || B < L,\n            (B > -1 || A(T, 'default')) && f.push(x);\n        }\n      }\n    }\n  }\n  const d = [l, f];\n  return D(e) && s.set(e, d), d;\n}\nfunction rs(e) {\n  return e[0] !== '$' && !nt(e);\n}\nfunction is(e) {\n  return e === null\n    ? 'null'\n    : typeof e == 'function'\n    ? e.name || ''\n    : typeof e == 'object' && e.constructor && e.constructor.name || '';\n}\nfunction os(e, t) {\n  return is(e) === is(t);\n}\nfunction ls(e, t) {\n  return I(t) ? t.findIndex((n) => os(n, e)) : P(t) && os(t, e) ? 0 : -1;\n}\nconst dr = (e) => e[0] === '_' || e === '$stable',\n  Mn = (e) => I(e) ? e.map(_e) : [_e(e)],\n  eo = (e, t, n) => {\n    if (t._n) return t;\n    const s = xi((...r) => Mn(t(...r)), n);\n    return s._c = !1, s;\n  },\n  hr = (e, t, n) => {\n    const s = e._ctx;\n    for (const r in e) {\n      if (dr(r)) continue;\n      const i = e[r];\n      if (P(i)) t[r] = eo(r, i, s);\n      else if (i != null) {\n        const l = Mn(i);\n        t[r] = () => l;\n      }\n    }\n  },\n  pr = (e, t) => {\n    const n = Mn(t);\n    e.slots.default = () => n;\n  },\n  to = (e, t) => {\n    const n = e.slots = cr();\n    if (e.vnode.shapeFlag & 32) {\n      const s = t._;\n      s ? (z(n, t), Ss(n, '_', s, !0)) : hr(t, n);\n    } else t && pr(e, t);\n  },\n  no = (e, t, n) => {\n    const { vnode: s, slots: r } = e;\n    let i = !0, l = U;\n    if (s.shapeFlag & 32) {\n      const f = t._;\n      f\n        ? n && f === 1 ? i = !1 : (z(r, t), !n && f === 1 && delete r._)\n        : (i = !t.$stable, hr(t, r)), l = t;\n    } else t && (pr(e, t), l = { default: 1 });\n    if (i) for (const f in r) !dr(f) && l[f] == null && delete r[f];\n  };\nfunction hn(e, t, n, s, r = !1) {\n  if (I(e)) {\n    e.forEach((E, T) => hn(E, t && (I(t) ? t[T] : t), n, s, r));\n    return;\n  }\n  if (Ot(s) && !r) return;\n  const i = s.shapeFlag & 4 ? Ln(s.component) || s.component.proxy : s.el,\n    l = r ? null : i,\n    { i: f, r: u } = e,\n    d = t && t.r,\n    h = f.refs === U ? f.refs = {} : f.refs,\n    x = f.setupState;\n  if (\n    d != null && d !== u &&\n    (G(d)\n      ? (h[d] = null, A(x, d) && (x[d] = null))\n      : ne(d) && (d.value = null)), P(u)\n  ) Te(u, f, 12, [l, h]);\n  else {\n    const E = G(u), T = ne(u);\n    if (E || T) {\n      const B = () => {\n        if (e.f) {\n          const L = E ? A(x, u) ? x[u] : h[u] : u.value;\n          r\n            ? I(L) && mn(L, i)\n            : I(L)\n            ? L.includes(i) || L.push(i)\n            : E\n            ? (h[u] = [i], A(x, u) && (x[u] = h[u]))\n            : (u.value = [i], e.k && (h[e.k] = u.value));\n        } else {E\n            ? (h[u] = l, A(x, u) && (x[u] = l))\n            : T && (u.value = l, e.k && (h[e.k] = l));}\n      };\n      l ? (B.id = -1, ee(B, n)) : B();\n    }\n  }\n}\nconst ee = Ii;\nfunction so(e) {\n  return ro(e);\n}\nfunction ro(e, t) {\n  const n = Is();\n  n.__VUE__ = !0;\n  const {\n      insert: s,\n      remove: r,\n      patchProp: i,\n      createElement: l,\n      createText: f,\n      createComment: u,\n      setText: d,\n      setElementText: h,\n      parentNode: x,\n      nextSibling: E,\n      setScopeId: T = oe,\n      insertStaticContent: B,\n    } = e,\n    L = (\n      o,\n      c,\n      a,\n      p = null,\n      g = null,\n      b = null,\n      v = void 0,\n      m = null,\n      y = !!c.dynamicChildren,\n    ) => {\n      if (o === c) return;\n      o && !et(o, c) && (p = mt(o), he(o, g, b, !0), o = null),\n        c.patchFlag === -2 && (y = !1, c.dynamicChildren = null);\n      const { type: _, ref: w, shapeFlag: O } = c;\n      switch (_) {\n        case Dt:\n          se(o, c, a, p);\n          break;\n        case at:\n          K(o, c, a, p);\n          break;\n        case en:\n          o == null && J(c, a, p, v);\n          break;\n        case fe:\n          pt(o, c, a, p, g, b, v, m, y);\n          break;\n        default:\n          O & 1\n            ? ie(o, c, a, p, g, b, v, m, y)\n            : O & 6\n            ? gt(o, c, a, p, g, b, v, m, y)\n            : (O & 64 || O & 128) && _.process(o, c, a, p, g, b, v, m, y, Qe);\n      }\n      w != null && g && hn(w, o && o.ref, b, c || o, !c);\n    },\n    se = (o, c, a, p) => {\n      if (o == null) s(c.el = f(c.children), a, p);\n      else {\n        const g = c.el = o.el;\n        c.children !== o.children && d(g, c.children);\n      }\n    },\n    K = (o, c, a, p) => {\n      o == null ? s(c.el = u(c.children || ''), a, p) : c.el = o.el;\n    },\n    J = (o, c, a, p) => {\n      [o.el, o.anchor] = B(o.children, c, a, p, o.el, o.anchor);\n    },\n    N = ({ el: o, anchor: c }, a, p) => {\n      let g;\n      for (; o && o !== c;) g = E(o), s(o, a, p), o = g;\n      s(c, a, p);\n    },\n    W = ({ el: o, anchor: c }) => {\n      let a;\n      for (; o && o !== c;) a = E(o), r(o), o = a;\n      r(c);\n    },\n    ie = (o, c, a, p, g, b, v, m, y) => {\n      c.type === 'svg' ? v = 'svg' : c.type === 'math' && (v = 'mathml'),\n        o == null ? M(c, a, p, g, b, v, m, y) : Wt(o, c, g, b, v, m, y);\n    },\n    M = (o, c, a, p, g, b, v, m) => {\n      let y, _;\n      const { props: w, shapeFlag: O, transition: C, dirs: S } = o;\n      if (\n        y = o.el = l(o.type, b, w && w.is, w),\n          O & 8\n            ? h(y, o.children)\n            : O & 16 && de(o.children, y, null, p, g, kt(o, b), v, m),\n          S && Ne(o, null, p, 'created'),\n          ye(y, o, o.scopeId, v, p),\n          w\n      ) {\n        for (const H in w) {\n          H !== 'value' && !nt(H) &&\n            i(y, H, null, w[H], b, o.children, p, g, xe);\n        }\n        'value' in w && i(y, 'value', null, w.value, b),\n          (_ = w.onVnodeBeforeMount) && ge(_, p, o);\n      }\n      S && Ne(o, null, p, 'beforeMount');\n      const R = io(g, C);\n      R && C.beforeEnter(y),\n        s(y, c, a),\n        ((_ = w && w.onVnodeMounted) || R || S) && ee(() => {\n          _ && ge(_, p, o), R && C.enter(y), S && Ne(o, null, p, 'mounted');\n        }, g);\n    },\n    ye = (o, c, a, p, g) => {\n      if (a && T(o, a), p) for (let b = 0; b < p.length; b++) T(o, p[b]);\n      if (g) {\n        let b = g.subTree;\n        if (c === b) {\n          const v = g.vnode;\n          ye(o, v, v.scopeId, v.slotScopeIds, g.parent);\n        }\n      }\n    },\n    de = (o, c, a, p, g, b, v, m, y = 0) => {\n      for (let _ = y; _ < o.length; _++) {\n        const w = o[_] = m ? Oe(o[_]) : _e(o[_]);\n        L(null, w, c, a, p, g, b, v, m);\n      }\n    },\n    Wt = (o, c, a, p, g, b, v) => {\n      const m = c.el = o.el;\n      let { patchFlag: y, dynamicChildren: _, dirs: w } = c;\n      y |= o.patchFlag & 16;\n      const O = o.props || U, C = c.props || U;\n      let S;\n      if (\n        a && je(a, !1),\n          (S = C.onVnodeBeforeUpdate) && ge(S, a, c, o),\n          w && Ne(c, o, a, 'beforeUpdate'),\n          a && je(a, !0),\n          _\n            ? Fe(o.dynamicChildren, _, m, a, p, kt(c, g), b)\n            : v || j(o, c, m, null, a, p, kt(c, g), b, !1),\n          y > 0\n      ) {\n        if (y & 16) Xe(m, c, O, C, a, p, g);\n        else if (\n          y & 2 && O.class !== C.class && i(m, 'class', null, C.class, g),\n            y & 4 && i(m, 'style', O.style, C.style, g),\n            y & 8\n        ) {\n          const R = c.dynamicProps;\n          for (let H = 0; H < R.length; H++) {\n            const $ = R[H], q = O[$], le = C[$];\n            (le !== q || $ === 'value') &&\n              i(m, $, q, le, g, o.children, a, p, xe);\n          }\n        }\n        y & 1 && o.children !== c.children && h(m, c.children);\n      } else !v && _ == null && Xe(m, c, O, C, a, p, g);\n      ((S = C.onVnodeUpdated) || w) && ee(() => {\n        S && ge(S, a, c, o), w && Ne(c, o, a, 'updated');\n      }, p);\n    },\n    Fe = (o, c, a, p, g, b, v) => {\n      for (let m = 0; m < c.length; m++) {\n        const y = o[m],\n          _ = c[m],\n          w = y.el && (y.type === fe || !et(y, _) || y.shapeFlag & 70)\n            ? x(y.el)\n            : a;\n        L(y, _, w, null, p, g, b, v, !0);\n      }\n    },\n    Xe = (o, c, a, p, g, b, v) => {\n      if (a !== p) {\n        if (a !== U) {\n          for (const m in a) {\n            !nt(m) && !(m in p) && i(o, m, a[m], null, v, c.children, g, b, xe);\n          }\n        }\n        for (const m in p) {\n          if (nt(m)) continue;\n          const y = p[m], _ = a[m];\n          y !== _ && m !== 'value' && i(o, m, _, y, v, c.children, g, b, xe);\n        }\n        'value' in p && i(o, 'value', a.value, p.value, v);\n      }\n    },\n    pt = (o, c, a, p, g, b, v, m, y) => {\n      const _ = c.el = o ? o.el : f(''), w = c.anchor = o ? o.anchor : f('');\n      let { patchFlag: O, dynamicChildren: C, slotScopeIds: S } = c;\n      S && (m = m ? m.concat(S) : S),\n        o == null\n          ? (s(_, a, p), s(w, a, p), de(c.children || [], a, w, g, b, v, m, y))\n          : O > 0 && O & 64 && C && o.dynamicChildren\n          ? (Fe(o.dynamicChildren, C, a, g, b, v, m),\n            (c.key != null || g && c === g.subTree) && gr(o, c, !0))\n          : j(o, c, a, w, g, b, v, m, y);\n    },\n    gt = (o, c, a, p, g, b, v, m, y) => {\n      c.slotScopeIds = m,\n        o == null\n          ? c.shapeFlag & 512\n            ? g.ctx.activate(c, a, p, v, y)\n            : qt(c, a, p, g, b, v, y)\n          : Hn(o, c, y);\n    },\n    qt = (o, c, a, p, g, b, v) => {\n      const m = o.component = mo(o, p, g);\n      if (nr(o) && (m.ctx.renderer = Qe), bo(m), m.asyncDep) {\n        if (g && g.registerDep(m, X), !o.el) {\n          const y = m.subTree = Pe(at);\n          K(null, y, c, a);\n        }\n      } else X(m, o, c, a, g, b, v);\n    },\n    Hn = (o, c, a) => {\n      const p = c.component = o.component;\n      if (Ei(o, c, a)) {\n        if (p.asyncDep && !p.asyncResolved) {\n          V(p, c, a);\n          return;\n        } else p.next = c, _i(p.update), p.effect.dirty = !0, p.update();\n      } else c.el = o.el, p.vnode = c;\n    },\n    X = (o, c, a, p, g, b, v) => {\n      const m = () => {\n          if (o.isMounted) {\n            let { next: w, bu: O, u: C, parent: S, vnode: R } = o;\n            {\n              const Ke = _r(o);\n              if (Ke) {\n                w && (w.el = R.el, V(o, w, v)),\n                  Ke.asyncDep.then(() => {\n                    o.isUnmounted || m();\n                  });\n                return;\n              }\n            }\n            let H = w, $;\n            je(o, !1),\n              w ? (w.el = R.el, V(o, w, v)) : w = R,\n              O && Jt(O),\n              ($ = w.props && w.props.onVnodeBeforeUpdate) && ge($, S, w, R),\n              je(o, !0);\n            const q = Zt(o), le = o.subTree;\n            o.subTree = q,\n              L(le, q, x(le.el), mt(le), o, g, b),\n              w.el = q.el,\n              H === null && Ci(o, q.el),\n              C && ee(C, g),\n              ($ = w.props && w.props.onVnodeUpdated) &&\n              ee(() => ge($, S, w, R), g);\n          } else {\n            let w;\n            const { el: O, props: C } = c,\n              { bm: S, m: R, parent: H } = o,\n              $ = Ot(c);\n            if (\n              je(o, !1),\n                S && Jt(S),\n                !$ && (w = C && C.onVnodeBeforeMount) && ge(w, H, c),\n                je(o, !0),\n                O && Un\n            ) {\n              const q = () => {\n                o.subTree = Zt(o), Un(O, o.subTree, o, g, null);\n              };\n              $\n                ? c.type.__asyncLoader().then(() => !o.isUnmounted && q())\n                : q();\n            } else {\n              const q = o.subTree = Zt(o);\n              L(null, q, a, p, o, g, b), c.el = q.el;\n            }\n            if (R && ee(R, g), !$ && (w = C && C.onVnodeMounted)) {\n              const q = c;\n              ee(() => ge(w, H, q), g);\n            }\n            (c.shapeFlag & 256 ||\n              H && Ot(H.vnode) && H.vnode.shapeFlag & 256) && o.a && ee(o.a, g),\n              o.isMounted = !0,\n              c = a = p = null;\n          }\n        },\n        y = o.effect = new vn(m, oe, () => Rn(_), o.scope),\n        _ = o.update = () => {\n          y.dirty && y.run();\n        };\n      _.id = o.uid, je(o, !0), _();\n    },\n    V = (o, c, a) => {\n      c.component = o;\n      const p = o.vnode.props;\n      o.vnode = c,\n        o.next = null,\n        ki(o, c.props, p, a),\n        no(o, c.children, a),\n        Ae(),\n        Qn(o),\n        Me();\n    },\n    j = (o, c, a, p, g, b, v, m, y = !1) => {\n      const _ = o && o.children,\n        w = o ? o.shapeFlag : 0,\n        O = c.children,\n        { patchFlag: C, shapeFlag: S } = c;\n      if (C > 0) {\n        if (C & 128) {\n          _t(_, O, a, p, g, b, v, m, y);\n          return;\n        } else if (C & 256) {\n          Le(_, O, a, p, g, b, v, m, y);\n          return;\n        }\n      }\n      S & 8\n        ? (w & 16 && xe(_, g, b), O !== _ && h(a, O))\n        : w & 16\n        ? S & 16 ? _t(_, O, a, p, g, b, v, m, y) : xe(_, g, b, !0)\n        : (w & 8 && h(a, ''), S & 16 && de(O, a, p, g, b, v, m, y));\n    },\n    Le = (o, c, a, p, g, b, v, m, y) => {\n      o = o || qe, c = c || qe;\n      const _ = o.length, w = c.length, O = Math.min(_, w);\n      let C;\n      for (C = 0; C < O; C++) {\n        const S = c[C] = y ? Oe(c[C]) : _e(c[C]);\n        L(o[C], S, a, null, g, b, v, m, y);\n      }\n      _ > w ? xe(o, g, b, !0, !1, O) : de(c, a, p, g, b, v, m, y, O);\n    },\n    _t = (o, c, a, p, g, b, v, m, y) => {\n      let _ = 0;\n      const w = c.length;\n      let O = o.length - 1, C = w - 1;\n      for (; _ <= O && _ <= C;) {\n        const S = o[_], R = c[_] = y ? Oe(c[_]) : _e(c[_]);\n        if (et(S, R)) L(S, R, a, null, g, b, v, m, y);\n        else break;\n        _++;\n      }\n      for (; _ <= O && _ <= C;) {\n        const S = o[O], R = c[C] = y ? Oe(c[C]) : _e(c[C]);\n        if (et(S, R)) L(S, R, a, null, g, b, v, m, y);\n        else break;\n        O--, C--;\n      }\n      if (_ > O) {\n        if (_ <= C) {\n          const S = C + 1, R = S < w ? c[S].el : p;\n          for (\n            ;\n            _ <= C;\n          ) {\n            L(null, c[_] = y ? Oe(c[_]) : _e(c[_]), a, R, g, b, v, m, y), _++;\n          }\n        }\n      } else if (_ > C) for (; _ <= O;) he(o[_], g, b, !0), _++;\n      else {\n        const S = _, R = _, H = new Map();\n        for (_ = R; _ <= C; _++) {\n          const re = c[_] = y ? Oe(c[_]) : _e(c[_]);\n          re.key != null && H.set(re.key, _);\n        }\n        let $, q = 0;\n        const le = C - R + 1;\n        let Ke = !1, Vn = 0;\n        const ke = new Array(le);\n        for (_ = 0; _ < le; _++) ke[_] = 0;\n        for (_ = S; _ <= O; _++) {\n          const re = o[_];\n          if (q >= le) {\n            he(re, g, b, !0);\n            continue;\n          }\n          let pe;\n          if (re.key != null) pe = H.get(re.key);\n          else {for ($ = R; $ <= C; $++) {\n              if (ke[$ - R] === 0 && et(re, c[$])) {\n                pe = $;\n                break;\n              }\n            }}\n          pe === void 0\n            ? he(re, g, b, !0)\n            : (ke[pe - R] = _ + 1,\n              pe >= Vn ? Vn = pe : Ke = !0,\n              L(re, c[pe], a, null, g, b, v, m, y),\n              q++);\n        }\n        const Dn = Ke ? oo(ke) : qe;\n        for ($ = Dn.length - 1, _ = le - 1; _ >= 0; _--) {\n          const re = R + _, pe = c[re], Bn = re + 1 < w ? c[re + 1].el : p;\n          ke[_] === 0\n            ? L(null, pe, a, Bn, g, b, v, m, y)\n            : Ke && ($ < 0 || _ !== Dn[$] ? He(pe, a, Bn, 2) : $--);\n        }\n      }\n    },\n    He = (o, c, a, p, g = null) => {\n      const { el: b, type: v, transition: m, children: y, shapeFlag: _ } = o;\n      if (_ & 6) {\n        He(o.component.subTree, c, a, p);\n        return;\n      }\n      if (_ & 128) {\n        o.suspense.move(c, a, p);\n        return;\n      }\n      if (_ & 64) {\n        v.move(o, c, a, Qe);\n        return;\n      }\n      if (v === fe) {\n        s(b, c, a);\n        for (let O = 0; O < y.length; O++) He(y[O], c, a, p);\n        s(o.anchor, c, a);\n        return;\n      }\n      if (v === en) {\n        N(o, c, a);\n        return;\n      }\n      if (p !== 2 && _ & 1 && m) {\n        if (p === 0) {\n          m.beforeEnter(b), s(b, c, a), ee(() => m.enter(b), g);\n        } else {\n          const { leave: O, delayLeave: C, afterLeave: S } = m,\n            R = () => s(b, c, a),\n            H = () => {\n              O(b, () => {\n                R(), S && S();\n              });\n            };\n          C ? C(b, R, H) : H();\n        }\n      } else s(b, c, a);\n    },\n    he = (o, c, a, p = !1, g = !1) => {\n      const {\n        type: b,\n        props: v,\n        ref: m,\n        children: y,\n        dynamicChildren: _,\n        shapeFlag: w,\n        patchFlag: O,\n        dirs: C,\n      } = o;\n      if (m != null && hn(m, null, a, o, !0), w & 256) {\n        c.ctx.deactivate(o);\n        return;\n      }\n      const S = w & 1 && C, R = !Ot(o);\n      let H;\n      if (R && (H = v && v.onVnodeBeforeUnmount) && ge(H, c, o), w & 6) {\n        Cr(o.component, a, p);\n      } else {\n        if (w & 128) {\n          o.suspense.unmount(a, p);\n          return;\n        }\n        S && Ne(o, null, c, 'beforeUnmount'),\n          w & 64\n            ? o.type.remove(o, c, a, g, Qe, p)\n            : _ && (b !== fe || O > 0 && O & 64)\n            ? xe(_, c, a, !1, !0)\n            : (b === fe && O & 384 || !g && w & 16) && xe(y, c, a),\n          p && Nn(o);\n      }\n      (R && (H = v && v.onVnodeUnmounted) || S) && ee(() => {\n        H && ge(H, c, o), S && Ne(o, null, c, 'unmounted');\n      }, a);\n    },\n    Nn = (o) => {\n      const { type: c, el: a, anchor: p, transition: g } = o;\n      if (c === fe) {\n        Er(a, p);\n        return;\n      }\n      if (c === en) {\n        W(o);\n        return;\n      }\n      const b = () => {\n        r(a), g && !g.persisted && g.afterLeave && g.afterLeave();\n      };\n      if (o.shapeFlag & 1 && g && !g.persisted) {\n        const { leave: v, delayLeave: m } = g, y = () => v(a, b);\n        m ? m(o.el, b, y) : y();\n      } else b();\n    },\n    Er = (o, c) => {\n      let a;\n      for (; o !== c;) a = E(o), r(o), o = a;\n      r(c);\n    },\n    Cr = (o, c, a) => {\n      const { bum: p, scope: g, update: b, subTree: v, um: m } = o;\n      p && Jt(p),\n        g.stop(),\n        b && (b.active = !1, he(v, o, c, a)),\n        m && ee(m, c),\n        ee(() => {\n          o.isUnmounted = !0;\n        }, c),\n        c && c.pendingBranch && !c.isUnmounted && o.asyncDep &&\n        !o.asyncResolved && o.suspenseId === c.pendingId &&\n        (c.deps--, c.deps === 0 && c.resolve());\n    },\n    xe = (o, c, a, p = !1, g = !1, b = 0) => {\n      for (let v = b; v < o.length; v++) he(o[v], c, a, p, g);\n    },\n    mt = (o) =>\n      o.shapeFlag & 6\n        ? mt(o.component.subTree)\n        : o.shapeFlag & 128\n        ? o.suspense.next()\n        : E(o.anchor || o.el);\n  let zt = !1;\n  const jn = (o, c, a) => {\n      o == null\n        ? c._vnode && he(c._vnode, null, null, !0)\n        : L(c._vnode || null, o, c, null, null, null, a),\n        zt || (zt = !0, Qn(), Js(), zt = !1),\n        c._vnode = o;\n    },\n    Qe = {\n      p: L,\n      um: he,\n      m: He,\n      r: Nn,\n      mt: qt,\n      mc: de,\n      pc: j,\n      pbc: Fe,\n      n: mt,\n      o: e,\n    };\n  let $n, Un;\n  return { render: jn, hydrate: $n, createApp: Zi(jn, $n) };\n}\nfunction kt({ type: e, props: t }, n) {\n  return n === 'svg' && e === 'foreignObject' ||\n      n === 'mathml' && e === 'annotation-xml' && t && t.encoding &&\n        t.encoding.includes('html')\n    ? void 0\n    : n;\n}\nfunction je({ effect: e, update: t }, n) {\n  e.allowRecurse = t.allowRecurse = n;\n}\nfunction io(e, t) {\n  return (!e || e && !e.pendingBranch) && t && !t.persisted;\n}\nfunction gr(e, t, n = !1) {\n  const s = e.children, r = t.children;\n  if (I(s) && I(r)) {\n    for (let i = 0; i < s.length; i++) {\n      const l = s[i];\n      let f = r[i];\n      f.shapeFlag & 1 && !f.dynamicChildren &&\n      ((f.patchFlag <= 0 || f.patchFlag === 32) &&\n        (f = r[i] = Oe(r[i]), f.el = l.el),\n        n || gr(l, f)), f.type === Dt && (f.el = l.el);\n    }\n  }\n}\nfunction oo(e) {\n  const t = e.slice(), n = [0];\n  let s, r, i, l, f;\n  const u = e.length;\n  for (s = 0; s < u; s++) {\n    const d = e[s];\n    if (d !== 0) {\n      if (r = n[n.length - 1], e[r] < d) {\n        t[s] = r, n.push(s);\n        continue;\n      }\n      for (i = 0, l = n.length - 1; i < l;) {\n        f = i + l >> 1, e[n[f]] < d ? i = f + 1 : l = f;\n      }\n      d < e[n[i]] && (i > 0 && (t[s] = n[i - 1]), n[i] = s);\n    }\n  }\n  for (i = n.length, l = n[i - 1]; i-- > 0;) n[i] = l, l = t[l];\n  return n;\n}\nfunction _r(e) {\n  const t = e.subTree.component;\n  if (t) return t.asyncDep && !t.asyncResolved ? t : _r(t);\n}\nconst lo = (e) => e.__isTeleport,\n  fe = Symbol.for('v-fgt'),\n  Dt = Symbol.for('v-txt'),\n  at = Symbol.for('v-cmt'),\n  en = Symbol.for('v-stc'),\n  ot = [];\nlet ue = null;\nfunction mr(e = !1) {\n  ot.push(ue = e ? null : []);\n}\nfunction co() {\n  ot.pop(), ue = ot[ot.length - 1] || null;\n}\nlet dt = 1;\nfunction cs(e) {\n  dt += e;\n}\nfunction fo(e) {\n  return e.dynamicChildren = dt > 0 ? ue || qe : null,\n    co(),\n    dt > 0 && ue && ue.push(e),\n    e;\n}\nfunction br(e, t, n, s, r, i) {\n  return fo(Z(e, t, n, s, r, i, !0));\n}\nfunction uo(e) {\n  return e ? e.__v_isVNode === !0 : !1;\n}\nfunction et(e, t) {\n  return e.type === t.type && e.key === t.key;\n}\nconst yr = ({ key: e }) => e ?? null,\n  It = (\n    { ref: e, ref_key: t, ref_for: n },\n  ) => (typeof e == 'number' && (e = '' + e),\n    e != null\n      ? G(e) || ne(e) || P(e) ? { i: be, r: e, k: t, f: !!n } : e\n      : null);\nfunction Z(\n  e,\n  t = null,\n  n = null,\n  s = 0,\n  r = null,\n  i = e === fe ? 0 : 1,\n  l = !1,\n  f = !1,\n) {\n  const u = {\n    __v_isVNode: !0,\n    __v_skip: !0,\n    type: e,\n    props: t,\n    key: t && yr(t),\n    ref: t && It(t),\n    scopeId: Ut,\n    slotScopeIds: null,\n    children: n,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag: i,\n    patchFlag: s,\n    dynamicProps: r,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: be,\n  };\n  return f\n    ? (Fn(u, n), i & 128 && e.normalize(u))\n    : n && (u.shapeFlag |= G(n) ? 8 : 16),\n    dt > 0 && !l && ue && (u.patchFlag > 0 || i & 6) && u.patchFlag !== 32 &&\n    ue.push(u),\n    u;\n}\nconst Pe = ao;\nfunction ao(e, t = null, n = null, s = 0, r = null, i = !1) {\n  if ((!e || e === Oi) && (e = at), uo(e)) {\n    const f = Ye(e, t, !0);\n    return n && Fn(f, n),\n      dt > 0 && !i && ue &&\n      (f.shapeFlag & 6 ? ue[ue.indexOf(e)] = f : ue.push(f)),\n      f.patchFlag |= -2,\n      f;\n  }\n  if (wo(e) && (e = e.__vccOpts), t) {\n    t = ho(t);\n    let { class: f, style: u } = t;\n    f && !G(f) && (t.class = xn(f)),\n      D(u) && (Bs(u) && !I(u) && (u = z({}, u)), t.style = yn(u));\n  }\n  const l = G(e) ? 1 : Si(e) ? 128 : lo(e) ? 64 : D(e) ? 4 : P(e) ? 2 : 0;\n  return Z(e, t, n, s, r, l, i, !0);\n}\nfunction ho(e) {\n  return e ? Bs(e) || fr(e) ? z({}, e) : e : null;\n}\nfunction Ye(e, t, n = !1, s = !1) {\n  const { props: r, ref: i, patchFlag: l, children: f, transition: u } = e,\n    d = t ? po(r || {}, t) : r,\n    h = {\n      __v_isVNode: !0,\n      __v_skip: !0,\n      type: e.type,\n      props: d,\n      key: d && yr(d),\n      ref: t && t.ref\n        ? n && i ? I(i) ? i.concat(It(t)) : [i, It(t)] : It(t)\n        : i,\n      scopeId: e.scopeId,\n      slotScopeIds: e.slotScopeIds,\n      children: f,\n      target: e.target,\n      targetAnchor: e.targetAnchor,\n      staticCount: e.staticCount,\n      shapeFlag: e.shapeFlag,\n      patchFlag: t && e.type !== fe ? l === -1 ? 16 : l | 16 : l,\n      dynamicProps: e.dynamicProps,\n      dynamicChildren: e.dynamicChildren,\n      appContext: e.appContext,\n      dirs: e.dirs,\n      transition: u,\n      component: e.component,\n      suspense: e.suspense,\n      ssContent: e.ssContent && Ye(e.ssContent),\n      ssFallback: e.ssFallback && Ye(e.ssFallback),\n      el: e.el,\n      anchor: e.anchor,\n      ctx: e.ctx,\n      ce: e.ce,\n    };\n  return u && s && (h.transition = u.clone(h)), h;\n}\nfunction De(e = ' ', t = 0) {\n  return Pe(Dt, null, e, t);\n}\nfunction _e(e) {\n  return e == null || typeof e == 'boolean'\n    ? Pe(at)\n    : I(e)\n    ? Pe(fe, null, e.slice())\n    : typeof e == 'object'\n    ? Oe(e)\n    : Pe(Dt, null, String(e));\n}\nfunction Oe(e) {\n  return e.el === null && e.patchFlag !== -1 || e.memo ? e : Ye(e);\n}\nfunction Fn(e, t) {\n  let n = 0;\n  const { shapeFlag: s } = e;\n  if (t == null) t = null;\n  else if (I(t)) n = 16;\n  else if (typeof t == 'object') {\n    if (s & 65) {\n      const r = t.default;\n      r && (r._c && (r._d = !1), Fn(e, r()), r._c && (r._d = !0));\n      return;\n    } else {\n      n = 32;\n      const r = t._;\n      !r && !fr(t) ? t._ctx = be : r === 3 && be &&\n        (be.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));\n    }\n  } else {P(t)\n      ? (t = { default: t, _ctx: be }, n = 32)\n      : (t = String(t), s & 64 ? (n = 16, t = [De(t)]) : n = 8);}\n  e.children = t, e.shapeFlag |= n;\n}\nfunction po(...e) {\n  const t = {};\n  for (let n = 0; n < e.length; n++) {\n    const s = e[n];\n    for (const r in s) {\n      if (r === 'class') {\n        t.class !== s.class && (t.class = xn([t.class, s.class]));\n      } else if (r === 'style') t.style = yn([t.style, s.style]);\n      else if (Ft(r)) {\n        const i = t[r], l = s[r];\n        l && i !== l && !(I(i) && i.includes(l)) &&\n          (t[r] = i ? [].concat(i, l) : l);\n      } else r !== '' && (t[r] = s[r]);\n    }\n  }\n  return t;\n}\nfunction ge(e, t, n, s = null) {\n  ae(e, t, 7, [n, s]);\n}\nconst go = or();\nlet _o = 0;\nfunction mo(e, t, n) {\n  const s = e.type,\n    r = (t ? t.appContext : e.appContext) || go,\n    i = {\n      uid: _o++,\n      vnode: e,\n      type: s,\n      parent: t,\n      appContext: r,\n      root: null,\n      next: null,\n      subTree: null,\n      effect: null,\n      update: null,\n      scope: new jr(!0),\n      render: null,\n      proxy: null,\n      exposed: null,\n      exposeProxy: null,\n      withProxy: null,\n      provides: t ? t.provides : Object.create(r.provides),\n      accessCache: null,\n      renderCache: [],\n      components: null,\n      directives: null,\n      propsOptions: ar(s, r),\n      emitsOptions: Zs(s, r),\n      emit: null,\n      emitted: null,\n      propsDefaults: U,\n      inheritAttrs: s.inheritAttrs,\n      ctx: U,\n      data: U,\n      props: U,\n      attrs: U,\n      slots: U,\n      refs: U,\n      setupState: U,\n      setupContext: null,\n      attrsProxy: null,\n      slotsProxy: null,\n      suspense: n,\n      suspenseId: n ? n.pendingId : 0,\n      asyncDep: null,\n      asyncResolved: !1,\n      isMounted: !1,\n      isUnmounted: !1,\n      isDeactivated: !1,\n      bc: null,\n      c: null,\n      bm: null,\n      m: null,\n      bu: null,\n      u: null,\n      um: null,\n      bum: null,\n      da: null,\n      a: null,\n      rtg: null,\n      rtc: null,\n      ec: null,\n      sp: null,\n    };\n  return i.ctx = { _: i },\n    i.root = t ? t.root : i,\n    i.emit = yi.bind(null, i),\n    e.ce && e.ce(i),\n    i;\n}\nlet k = null, Mt, pn;\n{\n  const e = Is(),\n    t = (n, s) => {\n      let r;\n      return (r = e[n]) || (r = e[n] = []), r.push(s), (i) => {\n        r.length > 1 ? r.forEach((l) => l(i)) : r[0](i);\n      };\n    };\n  Mt = t('__VUE_INSTANCE_SETTERS__', (n) => k = n),\n    pn = t('__VUE_SSR_SETTERS__', (n) => Bt = n);\n}\nconst ht = (e) => {\n    const t = k;\n    return Mt(e), e.scope.on(), () => {\n      e.scope.off(), Mt(t);\n    };\n  },\n  fs = () => {\n    k && k.scope.off(), Mt(null);\n  };\nfunction xr(e) {\n  return e.vnode.shapeFlag & 4;\n}\nlet Bt = !1;\nfunction bo(e, t = !1) {\n  t && pn(t);\n  const { props: n, children: s } = e.vnode, r = xr(e);\n  Qi(e, n, r, t), to(e, s);\n  const i = r ? yo(e, t) : void 0;\n  return t && pn(!1), i;\n}\nfunction yo(e, t) {\n  const n = e.type;\n  e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, Ki);\n  const { setup: s } = n;\n  if (s) {\n    const r = e.setupContext = s.length > 1 ? vo(e) : null, i = ht(e);\n    Ae();\n    const l = Te(s, e, 0, [e.props, r]);\n    if (Me(), i(), ws(l)) {\n      if (l.then(fs, fs), t) {\n        return l.then((f) => {\n          us(e, f, t);\n        }).catch((f) => {\n          jt(f, e, 0);\n        });\n      }\n      e.asyncDep = l;\n    } else us(e, l, t);\n  } else vr(e, t);\n}\nfunction us(e, t, n) {\n  P(t)\n    ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t\n    : D(t) && (e.setupState = qs(t)), vr(e, n);\n}\nlet as;\nfunction vr(e, t, n) {\n  const s = e.type;\n  if (!e.render) {\n    if (!t && as && !s.render) {\n      const r = s.template || An(e).template;\n      if (r) {\n        const { isCustomElement: i, compilerOptions: l } = e.appContext.config,\n          { delimiters: f, compilerOptions: u } = s,\n          d = z(z({ isCustomElement: i, delimiters: f }, l), u);\n        s.render = as(r, d);\n      }\n    }\n    e.render = s.render || oe;\n  }\n  {\n    const r = ht(e);\n    Ae();\n    try {\n      Wi(e);\n    } finally {\n      Me(), r();\n    }\n  }\n}\nconst xo = {\n  get(e, t) {\n    return te(e, 'get', ''), e[t];\n  },\n};\nfunction vo(e) {\n  const t = (n) => {\n    e.exposed = n || {};\n  };\n  return {\n    attrs: new Proxy(e.attrs, xo),\n    slots: e.slots,\n    emit: e.emit,\n    expose: t,\n  };\n}\nfunction Ln(e) {\n  if (e.exposed) {\n    return e.exposeProxy ||\n      (e.exposeProxy = new Proxy(qs(oi(e.exposed)), {\n        get(t, n) {\n          if (n in t) return t[n];\n          if (n in rt) return rt[n](e);\n        },\n        has(t, n) {\n          return n in t || n in rt;\n        },\n      }));\n  }\n}\nfunction wo(e) {\n  return P(e) && '__vccOpts' in e;\n}\nconst Eo = (e, t) => li(e, t, Bt), Co = '3.4.26'; /**\n * @vue/runtime-dom v3.4.26\n * (c) 2018-present Yuxi (Evan) You and Vue contributors\n * @license MIT\n */\n\nconst Oo = 'http://www.w3.org/2000/svg',\n  So = 'http://www.w3.org/1998/Math/MathML',\n  Se = typeof document < 'u' ? document : null,\n  ds = Se && Se.createElement('template'),\n  Io = {\n    insert: (e, t, n) => {\n      t.insertBefore(e, n || null);\n    },\n    remove: (e) => {\n      const t = e.parentNode;\n      t && t.removeChild(e);\n    },\n    createElement: (e, t, n, s) => {\n      const r = t === 'svg'\n        ? Se.createElementNS(Oo, e)\n        : t === 'mathml'\n        ? Se.createElementNS(So, e)\n        : Se.createElement(e, n ? { is: n } : void 0);\n      return e === 'select' && s && s.multiple != null &&\n        r.setAttribute('multiple', s.multiple),\n        r;\n    },\n    createText: (e) => Se.createTextNode(e),\n    createComment: (e) => Se.createComment(e),\n    setText: (e, t) => {\n      e.nodeValue = t;\n    },\n    setElementText: (e, t) => {\n      e.textContent = t;\n    },\n    parentNode: (e) => e.parentNode,\n    nextSibling: (e) => e.nextSibling,\n    querySelector: (e) => Se.querySelector(e),\n    setScopeId(e, t) {\n      e.setAttribute(t, '');\n    },\n    insertStaticContent(e, t, n, s, r, i) {\n      const l = n ? n.previousSibling : t.lastChild;\n      if (r && (r === i || r.nextSibling)) {\n        for (\n          ;\n          t.insertBefore(r.cloneNode(!0), n),\n            !(r === i || !(r = r.nextSibling));\n        );\n      } else {\n        ds.innerHTML = s === 'svg'\n          ? `<svg>${e}</svg>`\n          : s === 'mathml'\n          ? `<math>${e}</math>`\n          : e;\n        const f = ds.content;\n        if (s === 'svg' || s === 'mathml') {\n          const u = f.firstChild;\n          for (; u.firstChild;) f.appendChild(u.firstChild);\n          f.removeChild(u);\n        }\n        t.insertBefore(f, n);\n      }\n      return [\n        l ? l.nextSibling : t.firstChild,\n        n ? n.previousSibling : t.lastChild,\n      ];\n    },\n  },\n  To = Symbol('_vtc');\nfunction Po(e, t, n) {\n  const s = e[To];\n  s && (t = (t ? [t, ...s] : [...s]).join(' ')),\n    t == null\n      ? e.removeAttribute('class')\n      : n\n      ? e.setAttribute('class', t)\n      : e.className = t;\n}\nconst hs = Symbol('_vod'),\n  Ro = Symbol('_vsh'),\n  Ao = Symbol(''),\n  Mo = /(^|;)\\s*display\\s*:/;\nfunction Fo(e, t, n) {\n  const s = e.style, r = G(n);\n  let i = !1;\n  if (n && !r) {\n    if (t) {\n      if (G(t)) {\n        for (const l of t.split(';')) {\n          const f = l.slice(0, l.indexOf(':')).trim();\n          n[f] == null && Tt(s, f, '');\n        }\n      } else for (const l in t) n[l] == null && Tt(s, l, '');\n    }\n    for (const l in n) l === 'display' && (i = !0), Tt(s, l, n[l]);\n  } else if (r) {\n    if (t !== n) {\n      const l = s[Ao];\n      l && (n += ';' + l), s.cssText = n, i = Mo.test(n);\n    }\n  } else t && e.removeAttribute('style');\n  hs in e && (e[hs] = i ? s.display : '', e[Ro] && (s.display = 'none'));\n}\nconst ps = /\\s*!important$/;\nfunction Tt(e, t, n) {\n  if (I(n)) n.forEach((s) => Tt(e, t, s));\n  else if (n == null && (n = ''), t.startsWith('--')) e.setProperty(t, n);\n  else {\n    const s = Lo(e, t);\n    ps.test(n)\n      ? e.setProperty(Ze(s), n.replace(ps, ''), 'important')\n      : e[s] = n;\n  }\n}\nconst gs = ['Webkit', 'Moz', 'ms'], tn = {};\nfunction Lo(e, t) {\n  const n = tn[t];\n  if (n) return n;\n  let s = Je(t);\n  if (s !== 'filter' && s in e) return tn[t] = s;\n  s = Os(s);\n  for (let r = 0; r < gs.length; r++) {\n    const i = gs[r] + s;\n    if (i in e) return tn[t] = i;\n  }\n  return t;\n}\nconst _s = 'http://www.w3.org/1999/xlink';\nfunction Ho(e, t, n, s, r) {\n  if (s && t.startsWith('xlink:')) {\n    n == null\n      ? e.removeAttributeNS(_s, t.slice(6, t.length))\n      : e.setAttributeNS(_s, t, n);\n  } else {\n    const i = Nr(t);\n    n == null || i && !Ts(n)\n      ? e.removeAttribute(t)\n      : e.setAttribute(t, i ? '' : n);\n  }\n}\nfunction No(e, t, n, s, r, i, l) {\n  if (t === 'innerHTML' || t === 'textContent') {\n    s && l(s, r, i), e[t] = n ?? '';\n    return;\n  }\n  const f = e.tagName;\n  if (t === 'value' && f !== 'PROGRESS' && !f.includes('-')) {\n    const d = f === 'OPTION' ? e.getAttribute('value') || '' : e.value,\n      h = n ?? '';\n    (d !== h || !('_value' in e)) && (e.value = h),\n      n == null && e.removeAttribute(t),\n      e._value = n;\n    return;\n  }\n  let u = !1;\n  if (n === '' || n == null) {\n    const d = typeof e[t];\n    d === 'boolean'\n      ? n = Ts(n)\n      : n == null && d === 'string'\n      ? (n = '', u = !0)\n      : d === 'number' && (n = 0, u = !0);\n  }\n  try {\n    e[t] = n;\n  } catch {}\n  u && e.removeAttribute(t);\n}\nfunction jo(e, t, n, s) {\n  e.addEventListener(t, n, s);\n}\nfunction $o(e, t, n, s) {\n  e.removeEventListener(t, n, s);\n}\nconst ms = Symbol('_vei');\nfunction Uo(e, t, n, s, r = null) {\n  const i = e[ms] || (e[ms] = {}), l = i[t];\n  if (s && l) l.value = s;\n  else {\n    const [f, u] = Vo(t);\n    if (s) {\n      const d = i[t] = Ko(s, r);\n      jo(e, f, d, u);\n    } else l && ($o(e, f, l, u), i[t] = void 0);\n  }\n}\nconst bs = /(?:Once|Passive|Capture)$/;\nfunction Vo(e) {\n  let t;\n  if (bs.test(e)) {\n    t = {};\n    let s;\n    for (; s = e.match(bs);) {\n      e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = !0;\n    }\n  }\n  return [e[2] === ':' ? e.slice(3) : Ze(e.slice(2)), t];\n}\nlet nn = 0;\nconst Do = Promise.resolve(),\n  Bo = () => nn || (Do.then(() => nn = 0), nn = Date.now());\nfunction Ko(e, t) {\n  const n = (s) => {\n    if (!s._vts) s._vts = Date.now();\n    else if (s._vts <= n.attached) return;\n    ae(Wo(s, n.value), t, 5, [s]);\n  };\n  return n.value = e, n.attached = Bo(), n;\n}\nfunction Wo(e, t) {\n  if (I(t)) {\n    const n = e.stopImmediatePropagation;\n    return e.stopImmediatePropagation = () => {\n      n.call(e), e._stopped = !0;\n    },\n      t.map((s) => (r) => !r._stopped && s && s(r));\n  } else return t;\n}\nconst ys = (e) =>\n    e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 &&\n    e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123,\n  qo = (e, t, n, s, r, i, l, f, u) => {\n    const d = r === 'svg';\n    t === 'class'\n      ? Po(e, s, d)\n      : t === 'style'\n      ? Fo(e, n, s)\n      : Ft(t)\n      ? _n(t) || Uo(e, t, n, s, l)\n      : (t[0] === '.'\n          ? (t = t.slice(1), !0)\n          : t[0] === '^'\n          ? (t = t.slice(1), !1)\n          : zo(e, t, s, d))\n      ? No(e, t, s, i, l, f, u)\n      : (t === 'true-value'\n        ? e._trueValue = s\n        : t === 'false-value' && (e._falseValue = s),\n        Ho(e, t, s, d));\n  };\nfunction zo(e, t, n, s) {\n  if (s) {\n    return !!(t === 'innerHTML' || t === 'textContent' ||\n      t in e && ys(t) && P(n));\n  }\n  if (\n    t === 'spellcheck' || t === 'draggable' || t === 'translate' ||\n    t === 'form' || t === 'list' && e.tagName === 'INPUT' ||\n    t === 'type' && e.tagName === 'TEXTAREA'\n  ) return !1;\n  if (t === 'width' || t === 'height') {\n    const r = e.tagName;\n    if (r === 'IMG' || r === 'VIDEO' || r === 'CANVAS' || r === 'SOURCE') {\n      return !1;\n    }\n  }\n  return ys(t) && G(n) ? !1 : t in e;\n}\nconst Go = z({ patchProp: qo }, Io);\nlet xs;\nfunction Jo() {\n  return xs || (xs = so(Go));\n}\nconst Yo = (...e) => {\n  const t = Jo().createApp(...e), { mount: n } = t;\n  return t.mount = (s) => {\n    const r = Xo(s);\n    if (!r) return;\n    const i = t._component;\n    !P(i) && !i.render && !i.template && (i.template = r.innerHTML),\n      r.innerHTML = '';\n    const l = n(r, !1, Zo(r));\n    return r instanceof Element &&\n      (r.removeAttribute('v-cloak'), r.setAttribute('data-v-app', '')),\n      l;\n  },\n    t;\n};\nfunction Zo(e) {\n  if (e instanceof SVGElement) return 'svg';\n  if (typeof MathMLElement == 'function' && e instanceof MathMLElement) {\n    return 'mathml';\n  }\n}\nfunction Xo(e) {\n  return G(e) ? document.querySelector(e) : e;\n}\nconst Qo =\n    \"data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20aria-hidden='true'%20role='img'%20class='iconify%20iconify--logos'%20width='37.07'%20height='36'%20preserveAspectRatio='xMidYMid%20meet'%20viewBox='0%200%20256%20198'%3e%3cpath%20fill='%2341B883'%20d='M204.8%200H256L128%20220.8L0%200h97.92L128%2051.2L157.44%200h47.36Z'%3e%3c/path%3e%3cpath%20fill='%2341B883'%20d='m0%200l128%20220.8L256%200h-51.2L128%20132.48L50.56%200H0Z'%3e%3c/path%3e%3cpath%20fill='%2335495E'%20d='M50.56%200L128%20133.12L204.8%200h-47.36L128%2051.2L97.92%200H50.56Z'%3e%3c/path%3e%3c/svg%3e\",\n  Kt = (e) => (Xs('data-v-aba76ec8'), e = e(), Qs(), e),\n  ko = { class: 'card' },\n  el = Kt(() =>\n    Z('p', null, [\n      De(' Edit '),\n      Z('code', null, 'components/HelloWorld.vue'),\n      De(' to test HMR '),\n    ], -1)\n  ),\n  tl = Kt(() =>\n    Z('p', null, [\n      De(' Check out '),\n      Z('a', {\n        href: 'https://vuejs.org/guide/quick-start.html#local',\n        target: '_blank',\n      }, 'create-vue'),\n      De(', the official Vue + Vite starter '),\n    ], -1)\n  ),\n  nl = Kt(() =>\n    Z('p', null, [\n      De(' Install '),\n      Z('a', {\n        href: 'https://github.com/johnsoncodehk/volar',\n        target: '_blank',\n      }, 'Volar'),\n      De(' in your IDE for a better DX '),\n    ], -1)\n  ),\n  sl = Kt(() =>\n    Z(\n      'p',\n      { class: 'read-the-docs' },\n      'Click on the Vite and Vue logos to learn more',\n      -1,\n    )\n  ),\n  rl = tr({\n    __name: 'HelloWorld',\n    props: { msg: {} },\n    setup(e) {\n      const t = ci(0);\n      return (\n        n,\n        s,\n      ) => (mr(),\n        br(fe, null, [\n          Z('h1', null, Wn(n.msg), 1),\n          Z('div', ko, [\n            Z(\n              'button',\n              { type: 'button', onClick: s[0] || (s[0] = (r) => t.value++) },\n              'count is ' + Wn(t.value),\n              1,\n            ),\n            el,\n          ]),\n          tl,\n          nl,\n          sl,\n        ], 64));\n    },\n  }),\n  wr = (e, t) => {\n    const n = e.__vccOpts || e;\n    for (const [s, r] of t) n[s] = r;\n    return n;\n  },\n  il = wr(rl, [['__scopeId', 'data-v-aba76ec8']]),\n  ol = (e) => (Xs('data-v-27cb24bb'), e = e(), Qs(), e),\n  ll = ol(() =>\n    Z('div', null, [\n      Z('a', { href: 'https://vitejs.dev', target: '_blank' }),\n      Z('a', { href: 'https://vuejs.org/', target: '_blank' }, [\n        Z('img', { src: Qo, class: 'logo vue', alt: 'Vue logo' }),\n      ]),\n    ], -1)\n  ),\n  cl = tr({\n    __name: 'App',\n    setup(e) {\n      return (\n        t,\n        n,\n      ) => (mr(), br(fe, null, [ll, Pe(il, { msg: 'Vite + Vue' })], 64));\n    },\n  }),\n  fl = wr(cl, [['__scopeId', 'data-v-27cb24bb']]);\nYo(fl).mount('#app');\n;\n",
} as UI;
////// END GENERATED CODE
